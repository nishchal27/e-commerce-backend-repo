# ğŸ—ï¸ E-Commerce Backend: Architecture, Modules & Experimentation Guide

> **Developer Playbook** â€” A practical, implementation-first guide for building a production-grade e-commerce backend with experimentation capabilities.

**Tech Stack:** NestJS Â· PostgreSQL Â· Redis Â· TypeScript Â· Docker Â· Prometheus Â· BullMQ Â· Prisma

---

## ğŸ“‹ Table of Contents

1. [Current State & Status](#-current-state--status)
2. [Architecture Overview](#-architecture-overview)
3. [Implementation Roadmap](#-implementation-roadmap)
4. [Module Specifications](#-module-specifications)
5. [Architecture Patterns](#-architecture-patterns)
6. [Event-Driven Architecture](#-event-driven-architecture)
7. [Experimentation Framework](#-experimentation-framework)
8. [Observability & Monitoring](#-observability--monitoring)
9. [Testing Strategy](#-testing-strategy)
10. [Database Schema](#-database-schema)
11. [File Structure](#-file-structure)
12. [Quick Start Tasks](#-quick-start-tasks)

---

## âœ… Current State & Status

### Implemented Modules

| Module | Status | Features | Documentation |
|--------|--------|----------|--------------|
| **Auth** | âœ… Complete | JWT, Refresh Tokens, Email Verification, Password Reset, Rate Limiting | [Auth Security Design](../Auth%20Security%20Design.mdx) |
| **Products** | âœ… Complete | CRUD, Variants, Repository Pattern | - |
| **Mailer** | âœ… Complete | BullMQ Queue, Templates, Provider Abstraction | - |
| **Experiments** | âœ… Complete | Experiment Tracking, Metrics Collection | - |

### Infrastructure & Common Services

| Component | Status | Purpose |
|-----------|--------|---------|
| **Prisma** | âœ… Complete | Database ORM, Migrations |
| **Redis** | âœ… Complete | Caching, BullMQ, Rate Limiting |
| **Prometheus** | âœ… Complete | Metrics Collection (`/metrics` endpoint) |
| **Rate Limiting** | âœ… Complete | Redis-backed, per-endpoint limits |
| **Request ID** | âœ… Complete | Request tracing middleware |
| **Logger (Pino)** | âœ… Complete | Structured JSON logging |

### Database Schema (Prisma)

**Implemented Models:**
- âœ… `User` - Authentication, roles (CUSTOMER, ADMIN, MANAGER)
- âœ… `RefreshToken` - HMAC-hashed refresh tokens
- âœ… `Product` - Product catalog
- âœ… `ProductVariant` - SKUs, pricing, stock
- âœ… `Order` - Order lifecycle (schema ready)
- âœ… `InventoryReservation` - Stock reservations (schema ready)
- âœ… `Review` - Product reviews (schema ready)
- âœ… `Experiment` - Experiment tracking

**Pending Implementation:**
- â³ `outbox` table (for event publishing)
- â³ `experiment_assignments` table (for A/B testing)

---

## ğŸ›ï¸ Architecture Overview

### Core Principles

1. **Modular Design** - Each feature is a self-contained NestJS module
2. **Event-Driven** - Domain events via Outbox pattern for eventual consistency
3. **Observable** - Structured logs, metrics, and traces for all operations
4. **Testable** - Unit, integration, and load tests for critical paths
5. **Secure** - Authentication, authorization, rate limiting, input validation
6. **Scalable** - Stateless services, Redis caching, async workers

### Technology Stack

| Layer | Technology | Purpose |
|-------|------------|---------|
| **Framework** | NestJS | Modular, TypeScript-first backend framework |
| **Database** | PostgreSQL | Transactional data, single source of truth |
| **ORM** | Prisma | Type-safe database access, migrations |
| **Cache/Queue** | Redis | Caching, BullMQ workers, rate limiting |
| **Metrics** | Prometheus | Observability and monitoring |
| **Logging** | Pino | Structured JSON logging |
| **Email** | Nodemailer + BullMQ | Async email processing |
| **Testing** | Jest + k6 | Unit/integration tests + load testing |

---

## ğŸ—ºï¸ Implementation Roadmap

### Phase 0: Foundation âœ… **COMPLETE**

**Status:** All prerequisites implemented

- âœ… Auth module with JWT + Refresh Tokens
- âœ… Products module with CRUD operations
- âœ… Mailer module with async processing
- âœ… Experiments module for tracking
- âœ… Request ID middleware
- âœ… Structured logging (Pino)
- âœ… Prometheus metrics
- âœ… Rate limiting

### Phase 1: Orders & Payments â³ **NEXT**

**Priority:** High | **Dependencies:** None

**Goals:**
- Implement `orders` module with lifecycle management
- Implement `payments` module with provider abstraction
- Add `outbox` table for reliable event publishing
- Emit domain events (`order.created.v1`, `order.paid.v1`)

**Tasks:**
- [ ] Create `OrdersModule` with service, controller, DTOs
- [ ] Implement order status state machine (CREATED â†’ PAID â†’ SHIPPED â†’ DELIVERED)
- [ ] Add idempotency key handling for order creation
- [ ] Create `PaymentsModule` with provider adapters (Stripe, PayPal)
- [ ] Implement webhook handling with signature verification
- [ ] Add `outbox` table to Prisma schema
- [ ] Create outbox writer utility
- [ ] Emit events via outbox pattern

**Database Changes:**
```prisma
// Add to schema.prisma
model Outbox {
  id        String   @id @default(uuid())
  topic     String
  payload   Json
  createdAt DateTime @default(now())
  sentAt    DateTime?
  attempts  Int      @default(0)
  locked    Boolean  @default(false)
  
  @@index([createdAt])
  @@map("outbox")
}
```

### Phase 2: Inventory & Cart â³ **PENDING**

**Priority:** High | **Dependencies:** Phase 1

**Goals:**
- Implement `inventory` module with reservation APIs
- Implement `cart` module with merge logic
- Add reservation strategies (optimistic vs pessimistic) for experiments

**Tasks:**
- [ ] Create `InventoryModule` with reservation APIs (`reserve`, `commit`, `release`)
- [ ] Implement stock management and multi-warehouse support
- [ ] Create `CartModule` for anonymous and authenticated carts
- [ ] Implement cart merge logic (anonymous â†’ user) with deterministic rules
- [ ] Add feature flag for reservation strategies
- [ ] Implement pessimistic locking strategy
- [ ] Implement optimistic locking strategy
- [ ] Add integration tests for reservation strategies

**Note:** `InventoryReservation` model already exists in schema.

### Phase 3: Background Workers â³ **PENDING**

**Priority:** Medium | **Dependencies:** Phase 1

**Goals:**
- Expand BullMQ workers for async processing
- Implement outbox publisher worker
- Add webhook retry mechanism

**Tasks:**
- [ ] Create outbox publisher worker (publish events to Redis Stream/Kafka)
- [ ] Implement webhook retry worker with exponential backoff
- [ ] Add payment reconciliation worker
- [ ] Create worker monitoring and health checks
- [ ] Add dead letter queue (DLQ) handling

**Note:** BullMQ is already configured for mailer. Extend for other workers.

### Phase 4: Search & Recommendations â³ **PENDING**

**Priority:** Medium | **Dependencies:** Phase 2

**Goals:**
- Add search indexing pipeline
- Implement recommendation endpoints
- A/B test recommendation algorithms

**Tasks:**
- [ ] Integrate Elasticsearch or Typesense for product search
- [ ] Create search indexing worker (sync products to search engine)
- [ ] Implement recommendation service (co-occurrence, content-based)
- [ ] Add recommendation endpoints as experiments
- [ ] Create search analytics and metrics

### Phase 5: Observability Enhancement â³ **PENDING**

**Priority:** Medium | **Dependencies:** None

**Goals:**
- Add OpenTelemetry traces
- Enhance Prometheus metrics
- Set up log aggregation (Loki/ELK)

**Tasks:**
- [ ] Add OpenTelemetry instrumentation for HTTP and DB
- [ ] Enhance Prometheus metrics (business metrics, custom counters)
- [ ] Set up log aggregation pipeline (Loki or ELK)
- [ ] Create Grafana dashboards
- [ ] Add distributed tracing (Jaeger/Tempo)

**Note:** Basic Prometheus metrics are already implemented.

### Phase 6: Testing & Validation â³ **PENDING**

**Priority:** High | **Dependencies:** All phases

**Goals:**
- Comprehensive test coverage
- Load testing scripts
- Chaos engineering

**Tasks:**
- [ ] Add unit tests for all modules (target: 80%+ coverage)
- [ ] Create integration tests for critical flows
- [ ] Add contract tests for external providers
- [ ] Create property-based tests (fast-check)
- [ ] Add k6 load test scripts for all endpoints
- [ ] Implement chaos testing scripts
- [ ] Add CI/CD test gates

**Note:** Auth module already has comprehensive tests. Extend to other modules.

### Phase 7: Integrations & Hardening â³ **PENDING**

**Priority:** Low | **Dependencies:** Phase 1-3

**Goals:**
- External integrations
- Admin panel
- Security hardening

**Tasks:**
- [ ] Integrate shipping providers (FedEx, UPS, etc.)
- [ ] Add accounting integration (QuickBooks)
- [ ] Create admin module with RBAC
- [ ] Implement audit logging
- [ ] Security hardening (secret management, TLS, scanning)
- [ ] Add fraud detection scoring

---

## ğŸ“¦ Module Specifications

### Core Modules (To Implement)

#### 1. Orders Module

**Responsibilities:**
- Order creation and validation
- Order lifecycle management (status transitions)
- Idempotency key handling
- Order history and audit logs

**Key Features:**
- State machine for order status
- Idempotent order creation
- Payment reconciliation hooks
- Event emission (`order.created`, `order.paid`, `order.shipped`)

**File Structure:**
```
src/modules/orders/
â”œâ”€â”€ orders.module.ts
â”œâ”€â”€ orders.service.ts
â”œâ”€â”€ orders.controller.ts
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-order.dto.ts
â”‚   â””â”€â”€ update-order-status.dto.ts
â”œâ”€â”€ entities/
â”‚   â””â”€â”€ order.entity.ts
â””â”€â”€ interfaces/
    â””â”€â”€ order-status.interface.ts
```

#### 2. Payments Module

**Responsibilities:**
- Payment provider abstraction (Stripe, PayPal)
- Payment processing (capture vs authorize)
- Webhook handling and verification
- Payment reconciliation

**Key Features:**
- Provider adapter pattern
- Idempotent webhook processing
- Retry mechanism for failed payments
- Payment status tracking

**File Structure:**
```
src/modules/payments/
â”œâ”€â”€ payments.module.ts
â”œâ”€â”€ payments.service.ts
â”œâ”€â”€ payments.controller.ts
â”œâ”€â”€ providers/
â”‚   â”œâ”€â”€ payment-provider.interface.ts
â”‚   â”œâ”€â”€ stripe.provider.ts
â”‚   â””â”€â”€ paypal.provider.ts
â”œâ”€â”€ dto/
â”‚   â””â”€â”€ process-payment.dto.ts
â””â”€â”€ processors/
    â””â”€â”€ payment-webhook.processor.ts
```

#### 3. Inventory Module

**Responsibilities:**
- Stock management and tracking
- Inventory reservations (reserve, commit, release)
- Multi-warehouse support
- Backorder handling

**Key Features:**
- Reservation APIs with TTL
- Optimistic vs pessimistic locking strategies
- Stock reconciliation
- Low stock alerts

**File Structure:**
```
src/modules/inventory/
â”œâ”€â”€ inventory.module.ts
â”œâ”€â”€ inventory.service.ts
â”œâ”€â”€ inventory.controller.ts
â”œâ”€â”€ strategies/
â”‚   â”œâ”€â”€ reservation-strategy.interface.ts
â”‚   â”œâ”€â”€ optimistic.strategy.ts
â”‚   â””â”€â”€ pessimistic.strategy.ts
â””â”€â”€ dto/
    â”œâ”€â”€ reserve-inventory.dto.ts
    â””â”€â”€ commit-reservation.dto.ts
```

#### 4. Cart Module

**Responsibilities:**
- Anonymous cart management
- Authenticated cart management
- Cart merging (anonymous â†’ user)
- Promo code application

**Key Features:**
- Redis-backed cart storage
- Deterministic merge rules
- Price calculation pipeline
- Cart expiration (TTL)

**File Structure:**
```
src/modules/cart/
â”œâ”€â”€ cart.module.ts
â”œâ”€â”€ cart.service.ts
â”œâ”€â”€ cart.controller.ts
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ cart-merge.util.ts
â””â”€â”€ dto/
    â”œâ”€â”€ add-to-cart.dto.ts
    â””â”€â”€ merge-cart.dto.ts
```

### Supporting Modules

| Module | Purpose | Priority |
|--------|---------|----------|
| **Catalog** | Product variants, attributes, categories | Medium |
| **Pricing & Promotions** | Promo engine, dynamic pricing | Medium |
| **Shipping** | Rate calculation, label generation | Low |
| **Returns** | RMA, refunds, restock logic | Low |
| **Reviews** | Product reviews and ratings | Low |
| **Admin** | RBAC, dashboards, manual overrides | Medium |
| **Analytics** | Events ingestion, materialized views | Medium |
| **Search** | Full-text search, faceting | Medium |
| **Recommendations** | Recommendation algorithms | Low |

---

## ğŸ—ï¸ Architecture Patterns

### 1. Event-Driven Architecture

**Pattern:** Outbox â†’ Event Bus â†’ Consumers

**Flow:**
1. Domain event created in same transaction as business logic
2. Event written to `outbox` table (same DB transaction)
3. Worker polls `outbox` and publishes to Redis Stream/Kafka
4. Consumers process events and update analytics/other services

**Benefits:**
- Guaranteed event delivery (no lost events)
- Decoupled services
- Event replay capability
- Audit trail

### 2. Repository Pattern

**Current Implementation:** Products module uses repository pattern

**Benefits:**
- Abstraction over data access
- Easier testing (mock repositories)
- Consistent data access patterns

### 3. Provider Abstraction

**Current Implementation:** Mailer module uses provider pattern

**Pattern:** Interface â†’ Multiple implementations â†’ Factory

**Benefits:**
- Easy to swap implementations
- Testable (mock providers)
- Supports multiple providers simultaneously

### 4. Strategy Pattern

**Use Cases:**
- Inventory reservation strategies (optimistic vs pessimistic)
- Recommendation algorithms
- Cache eviction policies

**Implementation:**
```typescript
interface ReservationStrategy {
  reserve(skuId: string, quantity: number): Promise<Reservation>;
}

class OptimisticStrategy implements ReservationStrategy { ... }
class PessimisticStrategy implements ReservationStrategy { ... }
```

### 5. Idempotency

**Pattern:** Idempotency keys for critical operations

**Use Cases:**
- Order creation
- Payment processing
- Webhook handling

**Implementation:**
- Store idempotency key in request
- Check if operation already processed
- Return same result if duplicate

---

## ğŸ“¨ Event-Driven Architecture

### Event Envelope Schema

All domain events must follow this consistent envelope:

```typescript
interface DomainEvent {
  event_id: string;        // UUID v4
  event_type: string;       // e.g., "order.created.v1"
  timestamp: string;        // ISO 8601
  source: string;           // Service name
  trace_id?: string;        // OpenTelemetry trace ID
  request_id?: string;      // Request ID from middleware
  payload: Record<string, any>;  // Domain-specific data
  meta?: {
    env: string;
    version: string;
    feature_flags?: string[];
  };
}
```

### Example Events

```typescript
// Order Created Event
{
  event_id: "550e8400-e29b-41d4-a716-446655440000",
  event_type: "order.created.v1",
  timestamp: "2025-11-12T10:00:00.000Z",
  source: "orders-service",
  trace_id: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01",
  request_id: "req-123",
  payload: {
    order_id: "order-456",
    user_id: "user-789",
    total_amount: 99.99,
    items: [...]
  },
  meta: {
    env: "production",
    version: "1.2.0",
    feature_flags: ["inventory.optimistic"]
  }
}
```

### Outbox Table Schema

```prisma
model Outbox {
  id        String   @id @default(uuid())
  topic     String   // Event topic/channel
  payload   Json     // Full event envelope
  createdAt DateTime @default(now())
  sentAt    DateTime? // When event was published
  attempts  Int      @default(0) // Retry count
  locked    Boolean  @default(false) // Lock for worker processing
  
  @@index([createdAt])
  @@index([sentAt])
  @@map("outbox")
}
```

### Event Publishing Flow

```typescript
// 1. Create order in transaction
await prisma.$transaction(async (tx) => {
  const order = await tx.order.create({ ... });
  
  // 2. Write event to outbox (same transaction)
  await tx.outbox.create({
    topic: 'order.created',
    payload: {
      event_id: uuid(),
      event_type: 'order.created.v1',
      timestamp: new Date().toISOString(),
      source: 'orders-service',
      payload: { order_id: order.id, ... }
    }
  });
  
  return order;
});

// 3. Worker publishes from outbox to event bus
// 4. Consumers process events
```

---

## ğŸ§ª Experimentation Framework

### Experiment Flow

1. **Define** experiment in database (key, variants, sampling rate)
2. **Assign** variant deterministically (`assignVariant(experimentKey, subjectId)`)
3. **Record** assignment in `experiment_assignments` table
4. **Emit** `experiment.impression.v1` event via outbox
5. **Enforce** variant via feature flag in code paths
6. **Emit** `experiment.conversion.v1` when outcomes occur
7. **Analyze** results from event store

### Experiment Assignment

```typescript
function assignVariant(
  experimentKey: string,
  subjectId: string
): string {
  // Deterministic hash-based assignment
  const hash = crypto
    .createHash('sha256')
    .update(`${experimentKey}:${subjectId}`)
    .digest('hex');
  
  const experiment = getExperiment(experimentKey);
  const variantIndex = parseInt(hash.slice(0, 8), 16) % experiment.variants.length;
  
  return experiment.variants[variantIndex];
}
```

### Experiment Tables

```prisma
model Experiment {
  id          String   @id @default(uuid())
  key         String   @unique // e.g., "inventory.reservation_strategy"
  name        String
  description String?
  status      String   // "active", "paused", "completed"
  config      Json     // { variants: ["optimistic", "pessimistic"], sampling: 1.0 }
  createdAt   DateTime @default(now())
  
  @@map("experiments")
}

model ExperimentAssignment {
  id           String   @id @default(uuid())
  experimentId String
  experiment   Experiment @relation(fields: [experimentId], references: [id])
  subjectType  String   // "user", "session", "order"
  subjectId    String   // User ID, session ID, etc.
  variant      String   // Assigned variant
  assignedAt   DateTime @default(now())
  
  @@unique([experimentId, subjectType, subjectId])
  @@map("experiment_assignments")
}
```

### Example Experiments

#### 1. Inventory Reservation Strategy

**Goal:** Compare optimistic vs pessimistic locking

**Variants:**
- `optimistic` - Compare-and-swap approach
- `pessimistic` - SELECT FOR UPDATE approach

**Metrics:**
- Throughput (orders/sec)
- Latency (p95, p99)
- Failed reservations
- Oversells

#### 2. Recommendation Algorithm

**Goal:** Test recommendation approaches

**Variants:**
- `co_occurrence` - Item co-occurrence matrix
- `content_based` - Attribute similarity
- `top_sellers` - Simple heuristic

**Metrics:**
- Click-through rate (CTR)
- Conversion rate
- Revenue uplift

#### 3. Cache Eviction Policy

**Goal:** Compare caching strategies

**Variants:**
- `lru` - Least Recently Used
- `lfu` - Least Frequently Used
- `ttl` - Time To Live

**Metrics:**
- Cache hit ratio
- Average latency
- Memory usage

---

## ğŸ“Š Observability & Monitoring

### Current Implementation

âœ… **Prometheus Metrics**
- HTTP request metrics (duration, count, status codes)
- Auth-specific metrics (login attempts, token refreshes, registrations)
- Rate limit blocks

âœ… **Structured Logging (Pino)**
- JSON format logs
- Request ID correlation
- Contextual information (userId, email, role)

âœ… **Request ID Middleware**
- Propagates `X-Request-Id` header
- Correlates logs across services

### Metrics to Add

**Business Metrics:**
- `orders_created_total` - Counter
- `orders_by_status` - Gauge
- `payment_success_rate` - Gauge
- `inventory_reservations_total` - Counter
- `cart_abandonment_rate` - Gauge

**Performance Metrics:**
- `db_query_duration_seconds` - Histogram
- `cache_hit_ratio` - Gauge
- `worker_job_duration_seconds` - Histogram

**Error Metrics:**
- `payment_failures_total` - Counter (by reason)
- `inventory_oversells_total` - Counter
- `webhook_retries_total` - Counter

### Logging Best Practices

```typescript
// Good: Structured logging with context
this.logger.info({
  userId: user.id,
  email: user.email,
  orderId: order.id,
  amount: order.totalAmount,
  msg: 'Order created successfully'
});

// Bad: String interpolation
this.logger.info(`Order ${order.id} created for user ${user.id}`);
```

### Tracing

**Future:** Add OpenTelemetry for distributed tracing

**Benefits:**
- Track requests across services
- Identify performance bottlenecks
- Debug complex flows

---

## ğŸ§ª Testing Strategy

### Test Pyramid

```
        /\
       /  \      E2E Tests (10%)
      /____\     
     /      \    Integration Tests (20%)
    /________\   
   /          \  Unit Tests (70%)
  /____________\
```

### Unit Tests

**Coverage:**
- Business logic (services)
- Utilities and helpers
- Guards and decorators
- DTOs validation

**Example:**
```typescript
describe('OrdersService', () => {
  it('should create order with idempotency key', async () => {
    // Test implementation
  });
});
```

### Integration Tests

**Coverage:**
- API endpoints (E2E flows)
- Database operations
- Event publishing
- External service mocks

**Example:**
```typescript
describe('POST /orders', () => {
  it('should create order and emit event', async () => {
    // Test implementation
  });
});
```

### Load Tests (k6)

**Scenarios:**
- Checkout flow under load
- Inventory reservation concurrency
- Search endpoint performance
- Payment processing throughput

**Example:**
```javascript
import http from 'k6/http';
import { check } from 'k6';

export const options = {
  stages: [
    { duration: '30s', target: 20 },
    { duration: '1m', target: 50 },
    { duration: '30s', target: 0 },
  ],
};

export default function () {
  const res = http.post('https://api.example.com/orders', payload);
  check(res, { 'status is 201': (r) => r.status === 201 });
}
```

### Property-Based Tests

**Use Cases:**
- Cart merge logic
- Price calculation
- Coupon application

**Tool:** `fast-check`

```typescript
import fc from 'fast-check';

test('cart merge is deterministic', () => {
  fc.assert(
    fc.property(
      fc.array(fc.record({ sku: fc.string(), qty: fc.nat() })),
      (items) => {
        const result1 = mergeCart(items, []);
        const result2 = mergeCart(items, []);
        return deepEqual(result1, result2);
      }
    )
  );
});
```

---

## ğŸ—„ï¸ Database Schema

### Current Schema (Prisma)

**Models:**
- `User` - Authentication and authorization
- `RefreshToken` - Refresh token management
- `Product` - Product catalog
- `ProductVariant` - SKUs and pricing
- `Order` - Order management
- `InventoryReservation` - Stock reservations
- `Review` - Product reviews
- `Experiment` - Experiment tracking

### Schema to Add

**Outbox Table:**
```prisma
model Outbox {
  id        String   @id @default(uuid())
  topic     String
  payload   Json
  createdAt DateTime @default(now())
  sentAt    DateTime?
  attempts  Int      @default(0)
  locked    Boolean  @default(false)
  
  @@index([createdAt])
  @@index([sentAt])
  @@map("outbox")
}
```

**Experiment Assignments:**
```prisma
model ExperimentAssignment {
  id           String   @id @default(uuid())
  experimentId String
  experiment   Experiment @relation(fields: [experimentId], references: [id])
  subjectType  String
  subjectId    String
  variant      String
  assignedAt   DateTime @default(now())
  
  @@unique([experimentId, subjectType, subjectId])
  @@map("experiment_assignments")
}
```

---

## ğŸ“ File Structure

### Current Structure

```
src/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ auth/              âœ… Complete
â”‚   â”œâ”€â”€ products/           âœ… Complete
â”‚   â”œâ”€â”€ mailer/             âœ… Complete
â”‚   â””â”€â”€ experiments/        âœ… Complete
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â””â”€â”€ request-id.middleware.ts  âœ…
â”‚   â”œâ”€â”€ prometheus/         âœ… Complete
â”‚   â””â”€â”€ rate-limiting/      âœ… Complete
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ logger/             âœ… Complete
â”‚   â”œâ”€â”€ prisma/             âœ… Complete
â”‚   â””â”€â”€ redis/              âœ… Complete
â””â”€â”€ app.module.ts
```

### Target Structure (After All Phases)

```
src/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ auth/              âœ…
â”‚   â”œâ”€â”€ products/          âœ…
â”‚   â”œâ”€â”€ mailer/            âœ…
â”‚   â”œâ”€â”€ experiments/       âœ…
â”‚   â”œâ”€â”€ orders/            â³ Phase 1
â”‚   â”œâ”€â”€ payments/          â³ Phase 1
â”‚   â”œâ”€â”€ inventory/         â³ Phase 2
â”‚   â”œâ”€â”€ cart/              â³ Phase 2
â”‚   â”œâ”€â”€ shipping/          â³ Phase 7
â”‚   â”œâ”€â”€ reviews/           â³ Phase 7
â”‚   â””â”€â”€ admin/             â³ Phase 7
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”œâ”€â”€ outbox.service.ts
â”‚   â”‚   â””â”€â”€ event-bus.service.ts
â”‚   â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ prometheus/
â”‚   â””â”€â”€ rate-limiting/
â”œâ”€â”€ workers/
â”‚   â”œâ”€â”€ outbox-publisher.processor.ts
â”‚   â”œâ”€â”€ webhook-retry.processor.ts
â”‚   â””â”€â”€ payment-reconciliation.processor.ts
â””â”€â”€ lib/
    â”œâ”€â”€ logger/
    â”œâ”€â”€ prisma/
    â””â”€â”€ redis/
```

---

## ğŸš€ Quick Start Tasks

### Immediate Next Steps

1. **Create Outbox Table**
   ```bash
   # Add to prisma/schema.prisma
   # Run: npm run prisma:migrate
   ```

2. **Implement Orders Module**
   - Create `OrdersModule`, `OrdersService`, `OrdersController`
   - Add DTOs for order creation
   - Implement status state machine
   - Add idempotency key handling

3. **Implement Payments Module**
   - Create `PaymentsModule` with provider abstraction
   - Add Stripe provider implementation
   - Implement webhook handling
   - Add payment reconciliation

4. **Create Outbox Service**
   - Implement `OutboxService` for writing events
   - Create outbox publisher worker
   - Add event bus integration

5. **Add Business Metrics**
   - Extend `PrometheusService` with order/payment metrics
   - Add custom counters and gauges
   - Create Grafana dashboards

### Example Implementation Checklist

**Orders Module:**
- [ ] Create module structure
- [ ] Implement `createOrder()` with idempotency
- [ ] Add status state machine
- [ ] Write events to outbox
- [ ] Add unit tests
- [ ] Add integration tests
- [ ] Add Prometheus metrics
- [ ] Document API endpoints

**Payments Module:**
- [ ] Create module structure
- [ ] Implement provider interface
- [ ] Add Stripe provider
- [ ] Implement webhook handler
- [ ] Add idempotent webhook processing
- [ ] Add retry mechanism
- [ ] Add unit tests
- [ ] Add integration tests

---

## ğŸ“š Additional Resources

### Documentation
- [Auth Security Design](../Auth%20Security%20Design.mdx) - Complete auth implementation guide
- [K6 Experiments Setup](../K6%20Experiments%20â€”%20Setup%20&%20Docs.md) - Load testing guide
- [Quickstart Guide](../quickstart.md) - Getting started guide

### Best Practices

1. **Code Quality**
   - Follow NestJS conventions
   - Use TypeScript strictly
   - Add JSDoc comments
   - Keep functions small and focused

2. **Security**
   - Validate all inputs (DTOs)
   - Use parameterized queries (Prisma)
   - Implement rate limiting
   - Log security events

3. **Performance**
   - Use Redis for hot reads
   - Implement caching strategies
   - Optimize database queries
   - Monitor performance metrics

4. **Testing**
   - Write tests before implementation (TDD)
   - Aim for 80%+ coverage
   - Test edge cases
   - Use property-based tests for algorithms

---

**Last Updated:** 2025-11-12  
**Maintainer:** Development Team  
**Status:** Active Development
