# ğŸ—ï¸ E-Commerce Backend: Architecture, Modules & Experimentation Guide

> **Developer Playbook** â€” A practical, implementation-first guide for building a production-grade e-commerce backend with experimentation capabilities.

**Tech Stack:** NestJS Â· PostgreSQL Â· Redis Â· TypeScript Â· Docker Â· Prometheus Â· BullMQ Â· Prisma

---

## ğŸ“‹ Table of Contents

1. [Current State & Status](#-current-state--status)
2. [Architecture Overview](#-architecture-overview)
3. [Implementation Roadmap](#-implementation-roadmap)
4. [Module Specifications](#-module-specifications)
5. [Architecture Patterns](#-architecture-patterns)
6. [Event-Driven Architecture](#-event-driven-architecture)
7. [Experimentation Framework](#-experimentation-framework)
8. [Observability & Monitoring](#-observability--monitoring)
9. [Testing Strategy](#-testing-strategy)
10. [Database Schema](#-database-schema)
11. [File Structure](#-file-structure)
12. [Quick Start Tasks](#-quick-start-tasks)
13. [Strategic Implementation Plan](#-strategic-implementation-plan)
14. [Quality Standards & Best Practices](#-quality-standards--best-practices)
15. [Implementation Methodology](#-implementation-methodology)

---

## âœ… Current State & Status

### Implemented Modules

| Module | Status | Features | Documentation |
|--------|--------|----------|--------------|
| **Auth** | âœ… Complete | JWT, Refresh Tokens, Email Verification, Password Reset, Rate Limiting | [Auth Security Design](../Auth%20Security%20Design.mdx) |
| **Products** | âœ… Complete | CRUD, Variants, Repository Pattern | - |
| **Mailer** | âœ… Complete | BullMQ Queue, Templates, Provider Abstraction | - |
| **Experiments** | âœ… Complete | Experiment Tracking, Metrics Collection | - |
| **Orders** | âœ… Complete | Order lifecycle, State machine, Idempotency, Events | [Phase 1 Modules](../modules/Phase-1-Orders-Payments-Outbox.mdx) |
| **Payments** | âœ… Complete | Stripe integration, Webhooks, Provider abstraction | [Phase 1 Modules](../modules/Phase-1-Orders-Payments-Outbox.mdx) |
| **Outbox** | âœ… Complete | Transactional Outbox pattern, Event publishing | [Phase 1 Modules](../modules/Phase-1-Orders-Payments-Outbox.mdx) |
| **Inventory** | âœ… Complete | Reservation APIs, Optimistic/Pessimistic strategies, A/B testing | Phase 2 |
| **Cart** | âœ… Complete | Redis-backed storage, Cart merge, TTL expiration | Phase 2 |
| **Workers** | âœ… Complete | Webhook retry, Payment reconciliation, Monitoring, DLQ | [Phase 3 Modules](../modules/Phase-3-Background-Workers.mdx) |
| **Search** | âœ… Complete | Full-text search, Filtering, Pagination, Analytics | [Phase 4 Modules](../modules/Phase-4-Search-Recommendations.mdx) |
| **Recommendations** | âœ… Complete | Multiple strategies, A/B testing, Click tracking | [Phase 4 Modules](../modules/Phase-4-Search-Recommendations.mdx) |
| **Observability** | âœ… Complete | OpenTelemetry tracing, Enhanced metrics, Health checks | [Phase 5 Modules](../modules/Phase-5-Observability-Enhancement.mdx) |

### Infrastructure & Common Services

| Component | Status | Purpose |
|-----------|--------|---------|
| **Prisma** | âœ… Complete | Database ORM, Migrations |
| **Redis** | âœ… Complete | Caching, BullMQ, Rate Limiting |
| **Prometheus** | âœ… Complete | Metrics Collection (`/metrics` endpoint) |
| **Rate Limiting** | âœ… Complete | Redis-backed, per-endpoint limits |
| **Request ID** | âœ… Complete | Request tracing middleware |
| **Logger (Pino)** | âœ… Complete | Structured JSON logging |

### Database Schema (Prisma)

**Implemented Models:**
- âœ… `User` - Authentication, roles (CUSTOMER, ADMIN, MANAGER)
- âœ… `RefreshToken` - HMAC-hashed refresh tokens
- âœ… `Product` - Product catalog
- âœ… `ProductVariant` - SKUs, pricing, stock
- âœ… `Order` - Order lifecycle management
- âœ… `Payment` - Payment transactions and status tracking
- âœ… `InventoryReservation` - Stock reservations
- âœ… `Outbox` - Event publishing (transactional outbox pattern)
- âœ… `Review` - Product reviews (schema ready)
- âœ… `Experiment` - Experiment tracking

**Pending Implementation:**
- â³ `experiment_assignments` table (for A/B testing assignment tracking)

---

## ğŸ›ï¸ Architecture Overview

### Core Principles

1. **Modular Design** - Each feature is a self-contained NestJS module
2. **Event-Driven** - Domain events via Outbox pattern for eventual consistency
3. **Observable** - Structured logs, metrics, and traces for all operations
4. **Testable** - Unit, integration, and load tests for critical paths
5. **Secure** - Authentication, authorization, rate limiting, input validation
6. **Scalable** - Stateless services, Redis caching, async workers

### Technology Stack

| Layer | Technology | Purpose |
|-------|------------|---------|
| **Framework** | NestJS | Modular, TypeScript-first backend framework |
| **Database** | PostgreSQL | Transactional data, single source of truth |
| **ORM** | Prisma | Type-safe database access, migrations |
| **Cache/Queue** | Redis | Caching, BullMQ workers, rate limiting |
| **Metrics** | Prometheus | Observability and monitoring |
| **Logging** | Pino | Structured JSON logging |
| **Email** | Nodemailer + BullMQ | Async email processing |
| **Testing** | Jest + k6 | Unit/integration tests + load testing |

---

## ğŸ—ºï¸ Implementation Roadmap

### Phase 0: Foundation âœ… **COMPLETE**

**Status:** All prerequisites implemented

- âœ… Auth module with JWT + Refresh Tokens
- âœ… Products module with CRUD operations
- âœ… Mailer module with async processing
- âœ… Experiments module for tracking
- âœ… Request ID middleware
- âœ… Structured logging (Pino)
- âœ… Prometheus metrics
- âœ… Rate limiting

### Phase 1: Orders & Payments âœ… **COMPLETE**

**Status:** All Phase 1 components implemented

- âœ… Orders module with lifecycle management
- âœ… Payments module with Stripe integration
- âœ… Outbox pattern for reliable event publishing
- âœ… Event-driven architecture foundation
- âœ… Idempotency support
- âœ… Webhook handling

**Documentation:** [Phase 1 Modules Guide](../modules/Phase-1-Orders-Payments-Outbox.mdx)

### Phase 2: Inventory & Cart âœ… **COMPLETE**

**Status:** All Phase 2 components implemented

- âœ… Inventory module with reservation APIs (`reserve`, `commit`, `release`)
- âœ… Stock management and multi-warehouse support
- âœ… Cart module for anonymous and authenticated carts
- âœ… Cart merge logic (anonymous â†’ user) with deterministic rules
- âœ… Reservation strategies (optimistic and pessimistic)
- âœ… A/B testing integration for reservation strategies
- âœ… Comprehensive metrics and observations tracking

**Documentation:** Phase 2 implementation complete

### Phase 3: Background Workers âœ… **COMPLETE**

**Status:** All Phase 3 components implemented

- âœ… Outbox publisher worker (publish events to Redis Stream)
- âœ… Webhook retry worker with exponential backoff
- âœ… Payment reconciliation worker
- âœ… Worker monitoring and health checks
- âœ… Dead letter queue (DLQ) handling
- âœ… Comprehensive Prometheus metrics
- âœ… HTTP endpoints for monitoring and DLQ management

**Documentation:** [Phase 3 Modules](../modules/Phase-3-Background-Workers.mdx)

### Phase 4: Search & Recommendations âœ… **COMPLETE**

**Status:** All Phase 4 components implemented

- âœ… Search module with PostgreSQL full-text search (ILIKE)
- âœ… Search indexing worker (BullMQ) for async product indexing
- âœ… Recommendation service with multiple strategies (popularity, co-occurrence, content-based)
- âœ… Recommendation endpoints with A/B testing integration
- âœ… Search analytics and Prometheus metrics
- âœ… Comprehensive event emission for analytics

**Documentation:** [Phase 4 Modules](../modules/Phase-4-Search-Recommendations.mdx)

### Phase 5: Observability Enhancement âœ… **COMPLETE**

**Status:** All Phase 5 components implemented

- âœ… OpenTelemetry distributed tracing (HTTP, Express, PostgreSQL)
- âœ… Enhanced Prometheus metrics (database, cache, outbox)
- âœ… Comprehensive health checks (database, Redis, queues)
- âœ… Trace context propagation middleware
- âœ… Outbox metrics collection service
- âœ… Jaeger integration for trace collection

**Documentation:** [Phase 5 Modules](../modules/Phase-5-Observability-Enhancement.mdx)

**Note:** Log aggregation (Loki/ELK) and Grafana dashboards are recommended for production but not required for core functionality.

### Phase 6: Testing & Validation âœ… **COMPLETE**

**Status:** All Phase 6 components implemented

- âœ… Unit tests for core services (Orders, Payments, Inventory, Cart)
- âœ… Integration tests for critical flows (Orders E2E)
- âœ… Property-based tests for cart merge logic (fast-check)
- âœ… k6 load tests for Orders and Payments endpoints
- âœ… Test utilities and helpers
- âœ… Test coverage reporting
- âœ… Test scripts in package.json

**Documentation:** [Phase 6 Modules](../modules/Phase-6-Testing-Validation.mdx)

**Note:** Additional integration tests and chaos testing scripts can be added incrementally.

### Phase 7: Integrations & Hardening â³ **PENDING**

**Priority:** Low | **Dependencies:** Phase 1-3

**Goals:**
- External integrations
- Admin panel
- Security hardening

**Tasks:**
- [ ] Integrate shipping providers (FedEx, UPS, etc.)
- [ ] Add accounting integration (QuickBooks)
- [ ] Create admin module with RBAC
- [ ] Implement audit logging
- [ ] Security hardening (secret management, TLS, scanning)
- [ ] Add fraud detection scoring

---

## ğŸ“¦ Module Specifications

### Core Modules (To Implement)

#### 1. Orders Module

**Responsibilities:**
- Order creation and validation
- Order lifecycle management (status transitions)
- Idempotency key handling
- Order history and audit logs

**Key Features:**
- State machine for order status
- Idempotent order creation
- Payment reconciliation hooks
- Event emission (`order.created`, `order.paid`, `order.shipped`)

**File Structure:**
```
src/modules/orders/
â”œâ”€â”€ orders.module.ts
â”œâ”€â”€ orders.service.ts
â”œâ”€â”€ orders.controller.ts
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-order.dto.ts
â”‚   â””â”€â”€ update-order-status.dto.ts
â”œâ”€â”€ entities/
â”‚   â””â”€â”€ order.entity.ts
â””â”€â”€ interfaces/
    â””â”€â”€ order-status.interface.ts
```

#### 2. Payments Module

**Responsibilities:**
- Payment provider abstraction (Stripe, PayPal)
- Payment processing (capture vs authorize)
- Webhook handling and verification
- Payment reconciliation

**Key Features:**
- Provider adapter pattern
- Idempotent webhook processing
- Retry mechanism for failed payments
- Payment status tracking

**File Structure:**
```
src/modules/payments/
â”œâ”€â”€ payments.module.ts
â”œâ”€â”€ payments.service.ts
â”œâ”€â”€ payments.controller.ts
â”œâ”€â”€ providers/
â”‚   â”œâ”€â”€ payment-provider.interface.ts
â”‚   â”œâ”€â”€ stripe.provider.ts
â”‚   â””â”€â”€ paypal.provider.ts
â”œâ”€â”€ dto/
â”‚   â””â”€â”€ process-payment.dto.ts
â””â”€â”€ processors/
    â””â”€â”€ payment-webhook.processor.ts
```

#### 3. Inventory Module

**Responsibilities:**
- Stock management and tracking
- Inventory reservations (reserve, commit, release)
- Multi-warehouse support
- Backorder handling

**Key Features:**
- Reservation APIs with TTL
- Optimistic vs pessimistic locking strategies
- Stock reconciliation
- Low stock alerts

**File Structure:**
```
src/modules/inventory/
â”œâ”€â”€ inventory.module.ts
â”œâ”€â”€ inventory.service.ts
â”œâ”€â”€ inventory.controller.ts
â”œâ”€â”€ strategies/
â”‚   â”œâ”€â”€ reservation-strategy.interface.ts
â”‚   â”œâ”€â”€ optimistic.strategy.ts
â”‚   â””â”€â”€ pessimistic.strategy.ts
â””â”€â”€ dto/
    â”œâ”€â”€ reserve-inventory.dto.ts
    â””â”€â”€ commit-reservation.dto.ts
```

#### 4. Cart Module

**Responsibilities:**
- Anonymous cart management
- Authenticated cart management
- Cart merging (anonymous â†’ user)
- Promo code application

**Key Features:**
- Redis-backed cart storage
- Deterministic merge rules
- Price calculation pipeline
- Cart expiration (TTL)

**File Structure:**
```
src/modules/cart/
â”œâ”€â”€ cart.module.ts
â”œâ”€â”€ cart.service.ts
â”œâ”€â”€ cart.controller.ts
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ cart-merge.util.ts
â””â”€â”€ dto/
    â”œâ”€â”€ add-to-cart.dto.ts
    â””â”€â”€ merge-cart.dto.ts
```

### Supporting Modules

| Module | Purpose | Priority |
|--------|---------|----------|
| **Catalog** | Product variants, attributes, categories | Medium |
| **Pricing & Promotions** | Promo engine, dynamic pricing | Medium |
| **Shipping** | Rate calculation, label generation | Low |
| **Returns** | RMA, refunds, restock logic | Low |
| **Reviews** | Product reviews and ratings | Low |
| **Admin** | RBAC, dashboards, manual overrides | Medium |
| **Analytics** | Events ingestion, materialized views | Medium |
| **Search** | Full-text search, faceting | Medium |
| **Recommendations** | Recommendation algorithms | Low |

---

## ğŸ—ï¸ Architecture Patterns

### 1. Event-Driven Architecture

**Pattern:** Outbox â†’ Event Bus â†’ Consumers

**Flow:**
1. Domain event created in same transaction as business logic
2. Event written to `outbox` table (same DB transaction)
3. Worker polls `outbox` and publishes to Redis Stream/Kafka
4. Consumers process events and update analytics/other services

**Benefits:**
- Guaranteed event delivery (no lost events)
- Decoupled services
- Event replay capability
- Audit trail

### 2. Repository Pattern

**Current Implementation:** Products module uses repository pattern

**Benefits:**
- Abstraction over data access
- Easier testing (mock repositories)
- Consistent data access patterns

### 3. Provider Abstraction

**Current Implementation:** Mailer module uses provider pattern

**Pattern:** Interface â†’ Multiple implementations â†’ Factory

**Benefits:**
- Easy to swap implementations
- Testable (mock providers)
- Supports multiple providers simultaneously

### 4. Strategy Pattern

**Use Cases:**
- Inventory reservation strategies (optimistic vs pessimistic)
- Recommendation algorithms
- Cache eviction policies

**Implementation:**
```typescript
interface ReservationStrategy {
  reserve(skuId: string, quantity: number): Promise<Reservation>;
}

class OptimisticStrategy implements ReservationStrategy { ... }
class PessimisticStrategy implements ReservationStrategy { ... }
```

### 5. Idempotency

**Pattern:** Idempotency keys for critical operations

**Use Cases:**
- Order creation
- Payment processing
- Webhook handling

**Implementation:**
- Store idempotency key in request
- Check if operation already processed
- Return same result if duplicate

---

## ğŸ“¨ Event-Driven Architecture

### Event Envelope Schema

All domain events must follow this consistent envelope:

```typescript
interface DomainEvent {
  event_id: string;        // UUID v4
  event_type: string;       // e.g., "order.created.v1"
  timestamp: string;        // ISO 8601
  source: string;           // Service name
  trace_id?: string;        // OpenTelemetry trace ID
  request_id?: string;      // Request ID from middleware
  payload: Record<string, any>;  // Domain-specific data
  meta?: {
    env: string;
    version: string;
    feature_flags?: string[];
  };
}
```

### Example Events

```typescript
// Order Created Event
{
  event_id: "550e8400-e29b-41d4-a716-446655440000",
  event_type: "order.created.v1",
  timestamp: "2025-11-12T10:00:00.000Z",
  source: "orders-service",
  trace_id: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01",
  request_id: "req-123",
  payload: {
    order_id: "order-456",
    user_id: "user-789",
    total_amount: 99.99,
    items: [...]
  },
  meta: {
    env: "production",
    version: "1.2.0",
    feature_flags: ["inventory.optimistic"]
  }
}
```

### Outbox Table Schema

```prisma
model Outbox {
  id        String   @id @default(uuid())
  topic     String   // Event topic/channel
  payload   Json     // Full event envelope
  createdAt DateTime @default(now())
  sentAt    DateTime? // When event was published
  attempts  Int      @default(0) // Retry count
  locked    Boolean  @default(false) // Lock for worker processing
  
  @@index([createdAt])
  @@index([sentAt])
  @@map("outbox")
}
```

### Event Publishing Flow

```typescript
// 1. Create order in transaction
await prisma.$transaction(async (tx) => {
  const order = await tx.order.create({ ... });
  
  // 2. Write event to outbox (same transaction)
  await tx.outbox.create({
    topic: 'order.created',
    payload: {
      event_id: uuid(),
      event_type: 'order.created.v1',
      timestamp: new Date().toISOString(),
      source: 'orders-service',
      payload: { order_id: order.id, ... }
    }
  });
  
  return order;
});

// 3. Worker publishes from outbox to event bus
// 4. Consumers process events
```

---

## ğŸ§ª Experimentation Framework

### Experiment Flow

1. **Define** experiment in database (key, variants, sampling rate)
2. **Assign** variant deterministically (`assignVariant(experimentKey, subjectId)`)
3. **Record** assignment in `experiment_assignments` table
4. **Emit** `experiment.impression.v1` event via outbox
5. **Enforce** variant via feature flag in code paths
6. **Emit** `experiment.conversion.v1` when outcomes occur
7. **Analyze** results from event store

### Experiment Assignment

```typescript
function assignVariant(
  experimentKey: string,
  subjectId: string
): string {
  // Deterministic hash-based assignment
  const hash = crypto
    .createHash('sha256')
    .update(`${experimentKey}:${subjectId}`)
    .digest('hex');
  
  const experiment = getExperiment(experimentKey);
  const variantIndex = parseInt(hash.slice(0, 8), 16) % experiment.variants.length;
  
  return experiment.variants[variantIndex];
}
```

### Experiment Tables

```prisma
model Experiment {
  id          String   @id @default(uuid())
  key         String   @unique // e.g., "inventory.reservation_strategy"
  name        String
  description String?
  status      String   // "active", "paused", "completed"
  config      Json     // { variants: ["optimistic", "pessimistic"], sampling: 1.0 }
  createdAt   DateTime @default(now())
  
  @@map("experiments")
}

model ExperimentAssignment {
  id           String   @id @default(uuid())
  experimentId String
  experiment   Experiment @relation(fields: [experimentId], references: [id])
  subjectType  String   // "user", "session", "order"
  subjectId    String   // User ID, session ID, etc.
  variant      String   // Assigned variant
  assignedAt   DateTime @default(now())
  
  @@unique([experimentId, subjectType, subjectId])
  @@map("experiment_assignments")
}
```

### Example Experiments

#### 1. Inventory Reservation Strategy

**Goal:** Compare optimistic vs pessimistic locking

**Variants:**
- `optimistic` - Compare-and-swap approach
- `pessimistic` - SELECT FOR UPDATE approach

**Metrics:**
- Throughput (orders/sec)
- Latency (p95, p99)
- Failed reservations
- Oversells

#### 2. Recommendation Algorithm

**Goal:** Test recommendation approaches

**Variants:**
- `co_occurrence` - Item co-occurrence matrix
- `content_based` - Attribute similarity
- `top_sellers` - Simple heuristic

**Metrics:**
- Click-through rate (CTR)
- Conversion rate
- Revenue uplift

#### 3. Cache Eviction Policy

**Goal:** Compare caching strategies

**Variants:**
- `lru` - Least Recently Used
- `lfu` - Least Frequently Used
- `ttl` - Time To Live

**Metrics:**
- Cache hit ratio
- Average latency
- Memory usage

---

## ğŸ“Š Observability & Monitoring

### Current Implementation

âœ… **Prometheus Metrics**
- HTTP request metrics (duration, count, status codes)
- Auth-specific metrics (login attempts, token refreshes, registrations)
- Rate limit blocks

âœ… **Structured Logging (Pino)**
- JSON format logs
- Request ID correlation
- Contextual information (userId, email, role)

âœ… **Request ID Middleware**
- Propagates `X-Request-Id` header
- Correlates logs across services

### Metrics to Add

**Business Metrics:**
- `orders_created_total` - Counter
- `orders_by_status` - Gauge
- `payment_success_rate` - Gauge
- `inventory_reservations_total` - Counter
- `cart_abandonment_rate` - Gauge

**Performance Metrics:**
- `db_query_duration_seconds` - Histogram
- `cache_hit_ratio` - Gauge
- `worker_job_duration_seconds` - Histogram

**Error Metrics:**
- `payment_failures_total` - Counter (by reason)
- `inventory_oversells_total` - Counter
- `webhook_retries_total` - Counter

### Logging Best Practices

```typescript
// Good: Structured logging with context
this.logger.info({
  userId: user.id,
  email: user.email,
  orderId: order.id,
  amount: order.totalAmount,
  msg: 'Order created successfully'
});

// Bad: String interpolation
this.logger.info(`Order ${order.id} created for user ${user.id}`);
```

### Tracing

**Future:** Add OpenTelemetry for distributed tracing

**Benefits:**
- Track requests across services
- Identify performance bottlenecks
- Debug complex flows

---

## ğŸ§ª Testing Strategy

### Test Pyramid

```
        /\
       /  \      E2E Tests (10%)
      /____\     
     /      \    Integration Tests (20%)
    /________\   
   /          \  Unit Tests (70%)
  /____________\
```

### Unit Tests

**Coverage:**
- Business logic (services)
- Utilities and helpers
- Guards and decorators
- DTOs validation

**Example:**
```typescript
describe('OrdersService', () => {
  it('should create order with idempotency key', async () => {
    // Test implementation
  });
});
```

### Integration Tests

**Coverage:**
- API endpoints (E2E flows)
- Database operations
- Event publishing
- External service mocks

**Example:**
```typescript
describe('POST /orders', () => {
  it('should create order and emit event', async () => {
    // Test implementation
  });
});
```

### Load Tests (k6)

**Scenarios:**
- Checkout flow under load
- Inventory reservation concurrency
- Search endpoint performance
- Payment processing throughput

**Example:**
```javascript
import http from 'k6/http';
import { check } from 'k6';

export const options = {
  stages: [
    { duration: '30s', target: 20 },
    { duration: '1m', target: 50 },
    { duration: '30s', target: 0 },
  ],
};

export default function () {
  const res = http.post('https://api.example.com/orders', payload);
  check(res, { 'status is 201': (r) => r.status === 201 });
}
```

### Property-Based Tests

**Use Cases:**
- Cart merge logic
- Price calculation
- Coupon application

**Tool:** `fast-check`

```typescript
import fc from 'fast-check';

test('cart merge is deterministic', () => {
  fc.assert(
    fc.property(
      fc.array(fc.record({ sku: fc.string(), qty: fc.nat() })),
      (items) => {
        const result1 = mergeCart(items, []);
        const result2 = mergeCart(items, []);
        return deepEqual(result1, result2);
      }
    )
  );
});
```

---

## ğŸ—„ï¸ Database Schema

### Current Schema (Prisma)

**Models:**
- `User` - Authentication and authorization
- `RefreshToken` - Refresh token management
- `Product` - Product catalog
- `ProductVariant` - SKUs and pricing
- `Order` - Order management
- `InventoryReservation` - Stock reservations
- `Review` - Product reviews
- `Experiment` - Experiment tracking

### Schema to Add

**Outbox Table:**
```prisma
model Outbox {
  id        String   @id @default(uuid())
  topic     String
  payload   Json
  createdAt DateTime @default(now())
  sentAt    DateTime?
  attempts  Int      @default(0)
  locked    Boolean  @default(false)
  
  @@index([createdAt])
  @@index([sentAt])
  @@map("outbox")
}
```

**Experiment Assignments:**
```prisma
model ExperimentAssignment {
  id           String   @id @default(uuid())
  experimentId String
  experiment   Experiment @relation(fields: [experimentId], references: [id])
  subjectType  String
  subjectId    String
  variant      String
  assignedAt   DateTime @default(now())
  
  @@unique([experimentId, subjectType, subjectId])
  @@map("experiment_assignments")
}
```

---

## ğŸ“ File Structure

### Current Structure

```
src/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ auth/              âœ… Complete
â”‚   â”œâ”€â”€ products/           âœ… Complete
â”‚   â”œâ”€â”€ mailer/             âœ… Complete
â”‚   â””â”€â”€ experiments/        âœ… Complete
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â””â”€â”€ request-id.middleware.ts  âœ…
â”‚   â”œâ”€â”€ prometheus/         âœ… Complete
â”‚   â””â”€â”€ rate-limiting/      âœ… Complete
â”œâ”€â”€ lib/
â”‚   â”œâ”€â”€ logger/             âœ… Complete
â”‚   â”œâ”€â”€ prisma/             âœ… Complete
â”‚   â””â”€â”€ redis/              âœ… Complete
â””â”€â”€ app.module.ts
```

### Target Structure (After All Phases)

```
src/
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ auth/              âœ…
â”‚   â”œâ”€â”€ products/          âœ…
â”‚   â”œâ”€â”€ mailer/            âœ…
â”‚   â”œâ”€â”€ experiments/       âœ…
â”‚   â”œâ”€â”€ orders/            âœ… Phase 1
â”‚   â”œâ”€â”€ payments/          âœ… Phase 1
â”‚   â”œâ”€â”€ inventory/         âœ… Phase 2
â”‚   â”œâ”€â”€ cart/              âœ… Phase 2
â”‚   â”œâ”€â”€ search/            âœ… Phase 4
â”‚   â”œâ”€â”€ recommendations/   âœ… Phase 4
â”‚   â”œâ”€â”€ shipping/          â³ Phase 7
â”‚   â”œâ”€â”€ reviews/           â³ Phase 7
â”‚   â””â”€â”€ admin/             â³ Phase 7
â”œâ”€â”€ common/
â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”œâ”€â”€ outbox.service.ts              âœ…
â”‚   â”‚   â””â”€â”€ processors/
â”‚   â”‚       â””â”€â”€ outbox-publisher.processor.ts  âœ…
â”‚   â”œâ”€â”€ workers/
â”‚   â”‚   â”œâ”€â”€ processors/
â”‚   â”‚   â”‚   â”œâ”€â”€ webhook-retry.processor.ts     âœ…
â”‚   â”‚   â”‚   â”œâ”€â”€ payment-reconciliation.processor.ts  âœ…
â”‚   â”‚   â”‚   â””â”€â”€ search-indexing.processor.ts  âœ…
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ worker-monitoring.service.ts  âœ…
â”‚   â”‚   â”‚   â””â”€â”€ dlq-handler.service.ts        âœ…
â”‚   â”‚   â””â”€â”€ workers.module.ts                 âœ…
â”‚   â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ prometheus/
â”‚   â””â”€â”€ rate-limiting/
â””â”€â”€ lib/
    â”œâ”€â”€ logger/
    â”œâ”€â”€ prisma/
    â””â”€â”€ redis/
```

---

## ğŸš€ Quick Start Tasks

### Immediate Next Steps

1. **Create Outbox Table**
   ```bash
   # Add to prisma/schema.prisma
   # Run: npm run prisma:migrate
   ```

2. **Implement Orders Module**
   - Create `OrdersModule`, `OrdersService`, `OrdersController`
   - Add DTOs for order creation
   - Implement status state machine
   - Add idempotency key handling

3. **Implement Payments Module**
   - Create `PaymentsModule` with provider abstraction
   - Add Stripe provider implementation
   - Implement webhook handling
   - Add payment reconciliation

4. **Create Outbox Service**
   - Implement `OutboxService` for writing events
   - Create outbox publisher worker
   - Add event bus integration

5. **Add Business Metrics**
   - Extend `PrometheusService` with order/payment metrics
   - Add custom counters and gauges
   - Create Grafana dashboards

### Example Implementation Checklist

**Orders Module:**
- [ ] Create module structure
- [ ] Implement `createOrder()` with idempotency
- [ ] Add status state machine
- [ ] Write events to outbox
- [ ] Add unit tests
- [ ] Add integration tests
- [ ] Add Prometheus metrics
- [ ] Document API endpoints

**Payments Module:**
- [ ] Create module structure
- [ ] Implement provider interface
- [ ] Add Stripe provider
- [ ] Implement webhook handler
- [ ] Add idempotent webhook processing
- [ ] Add retry mechanism
- [ ] Add unit tests
- [ ] Add integration tests

---

## ğŸ¯ Strategic Implementation Plan

### Vision & Understanding

#### What This Codebase Is

A **production-grade, modular e-commerce backend** built on NestJS with:

- âœ… **Solid Foundation**: Auth, Products, Mailer, Experiments modules complete
- âœ… **Enterprise Patterns**: Repository, Provider abstraction, Strategy patterns
- âœ… **Observability**: Prometheus metrics, structured logging, request tracing
- âœ… **Security**: JWT + Refresh tokens, rate limiting, input validation
- âœ… **Scalability**: Redis caching, BullMQ workers, stateless design

#### What It Will Become

A **complete, production-ready e-commerce platform** with:

- Full order lifecycle management
- Payment processing with multiple providers
- Inventory management with reservation strategies
- Event-driven architecture for analytics and integrations
- A/B testing framework for algorithm optimization
- Comprehensive observability and monitoring

### Core Principles

1. **Quality Over Speed**
   - No shortcuts; production-ready from day one
   - Industry-standard patterns and practices
   - Comprehensive testing (unit, integration, load)
   - Documentation alongside code

2. **Incremental Delivery**
   - Build in phases, validate each phase
   - Each module is production-ready before moving on
   - Continuous integration and testing

3. **Production Mindset**
   - Error handling, logging, and monitoring from the start
   - Security considerations in every module
   - Performance optimization and scalability
   - Operational excellence

### Recommended Implementation Strategy

#### Phase 1: Orders & Payments (Critical Path)

**Why First:**
- Core business functionality
- Enables end-to-end user flows
- Foundation for other modules

**Implementation Approach:**

**1. Start with Outbox Pattern (Foundation)**
```
Week 1: Database & Infrastructure
- Add Outbox table to Prisma schema
- Create OutboxService (write events in same transaction)
- Create OutboxPublisher worker (BullMQ)
- Add integration tests for outbox pattern
```

**2. Orders Module (Business Logic)**
```
Week 2-3: Orders Module
- Create OrdersModule structure
- Implement order creation with idempotency
- Implement state machine (status transitions)
- Add event emission (order.created, order.updated)
- Comprehensive unit tests (80%+ coverage)
- Integration tests (E2E flows)
- Add Prometheus metrics
```

**3. Payments Module (Integration Layer)**
```
Week 4-5: Payments Module
- Create PaymentsModule with provider abstraction
- Implement Stripe provider (start with one)
- Add webhook handling with signature verification
- Implement idempotent webhook processing
- Add retry mechanism for failed payments
- Comprehensive tests (including webhook scenarios)
- Add payment metrics
```

**Quality Gates Before Moving On:**
- [ ] All unit tests passing (80%+ coverage)
- [ ] Integration tests for critical flows
- [ ] Load testing (k6) shows acceptable performance
- [ ] Prometheus metrics implemented
- [ ] Error handling and logging in place
- [ ] Code review and documentation complete

#### Phase 2: Inventory & Cart (Business Logic)

**Why Second:**
- Required for checkout flow
- Enables experimentation (reservation strategies)
- Builds on Orders foundation

**Implementation Approach:**

**1. Inventory Module (Data Integrity)**
```
Week 6-7: Inventory Module
- Create InventoryModule
- Implement reservation APIs (reserve, commit, release)
- Implement optimistic locking strategy
- Implement pessimistic locking strategy
- Add feature flag for strategy selection
- Add stock reconciliation
- Comprehensive tests (including concurrency)
- Load testing for reservation strategies
```

**2. Cart Module (User Experience)**
```
Week 8: Cart Module
- Create CartModule (Redis-backed)
- Implement anonymous cart
- Implement authenticated cart
- Implement cart merge logic (deterministic)
- Add cart expiration (TTL)
- Property-based tests for merge logic
- Integration tests
```

**Quality Gates:**
- [ ] Concurrency tests pass (no race conditions)
- [ ] Reservation strategies tested under load
- [ ] Cart merge logic verified with property-based tests
- [ ] Performance benchmarks documented

#### Phase 3: Background Workers (Reliability)

**Why Third:**
- Enables async processing
- Improves user experience (non-blocking)
- Required for scalability

**Implementation Approach:**
```
Week 9-10: Workers
- Extend BullMQ for outbox publisher (already started)
- Create webhook retry worker
- Create payment reconciliation worker
- Add DLQ handling
- Add worker monitoring
- Add health checks
- Comprehensive tests
```

---

## ğŸ“ Quality Standards & Best Practices

### Code Quality

**1. TypeScript Strict Mode**
```json
// tsconfig.json
{
  "strict": true,
  "noImplicitAny": true,
  "strictNullChecks": true,
  "strictFunctionTypes": true
}
```

**2. Consistent Code Style**
- ESLint + Prettier configured
- Consistent naming conventions
- Clear function and class names

**3. Documentation**
- JSDoc for all public methods
- README for each module
- Architecture decisions documented
- API documentation (OpenAPI/Swagger)

### Testing Standards

**1. Test Pyramid**
```
70% Unit Tests (business logic, utilities)
20% Integration Tests (API endpoints, DB operations)
10% E2E Tests (critical user flows)
```

**2. Coverage Requirements**
- Minimum 80% code coverage
- 100% coverage for critical paths (payments, orders)
- Property-based tests for algorithms

**3. Test Quality**
- Clear test names (describe what, not how)
- Arrange-Act-Assert pattern
- No flaky tests
- Fast execution (< 5 minutes for full suite)

### Security Standards

**1. Input Validation**
- DTOs with class-validator
- Sanitize all inputs
- Validate business rules

**2. Error Handling**
- Never expose internal errors
- Generic error messages for security
- Proper HTTP status codes
- Structured error logging

**3. Security Practices**
- Idempotency keys for critical operations
- Rate limiting on all public endpoints
- Webhook signature verification
- SQL injection prevention (Prisma handles this)

### Performance Standards

**1. Response Times**
- API endpoints: < 200ms (p95)
- Database queries: < 50ms (p95)
- Cache hit ratio: > 80%

**2. Scalability**
- Stateless services
- Horizontal scaling ready
- Database connection pooling
- Efficient queries (indexes, N+1 prevention)

### Observability Standards

**1. Logging**
- Structured JSON logs (Pino)
- Request ID correlation
- Appropriate log levels
- No sensitive data in logs

**2. Metrics**
- Business metrics (orders, payments, revenue)
- Performance metrics (latency, throughput)
- Error metrics (failure rates, error types)
- Custom metrics for experiments

**3. Monitoring**
- Alerts for critical failures
- Dashboards for key metrics
- Health check endpoints

---

## ğŸ”§ Implementation Methodology

### Development Workflow

**1. Design First**
```
- Create module design document
- Define API contracts (DTOs, interfaces)
- Design database schema changes
- Review with team (if applicable)
```

**2. Test-Driven Development (TDD)**
```
- Write failing tests first
- Implement minimal code to pass
- Refactor while keeping tests green
- Repeat
```

**3. Incremental Implementation**
```
- Start with core functionality
- Add features incrementally
- Test after each addition
- Refactor as needed
```

**4. Code Review Checklist**
```
- [ ] Code follows style guide
- [ ] Tests are comprehensive
- [ ] Error handling is proper
- [ ] Logging is appropriate
- [ ] Metrics are added
- [ ] Documentation is updated
- [ ] Security considerations addressed
```

### Module Implementation Template

For each new module, follow this structure:

```
src/modules/{module-name}/
â”œâ”€â”€ {module-name}.module.ts          # Module definition
â”œâ”€â”€ {module-name}.service.ts         # Business logic
â”œâ”€â”€ {module-name}.controller.ts      # HTTP endpoints
â”œâ”€â”€ {module-name}.service.spec.ts   # Unit tests
â”œâ”€â”€ dto/                             # Data Transfer Objects
â”‚   â”œâ”€â”€ create-{entity}.dto.ts
â”‚   â””â”€â”€ update-{entity}.dto.ts
â”œâ”€â”€ entities/                         # Domain entities (if needed)
â”‚   â””â”€â”€ {entity}.entity.ts
â”œâ”€â”€ interfaces/                       # TypeScript interfaces
â”‚   â””â”€â”€ {interface}.interface.ts
â”œâ”€â”€ strategies/                       # Strategy pattern implementations
â”‚   â””â”€â”€ {strategy}.strategy.ts
â”œâ”€â”€ processors/                       # BullMQ processors (if needed)
â”‚   â””â”€â”€ {processor}.processor.ts
â””â”€â”€ README.md                         # Module documentation
```

### Module Checklist

Before considering a module complete:

- [ ] All business logic implemented
- [ ] DTOs with validation
- [ ] Error handling and custom exceptions
- [ ] Unit tests (80%+ coverage)
- [ ] Integration tests
- [ ] Prometheus metrics
- [ ] Structured logging
- [ ] API documentation
- [ ] Module README
- [ ] Code review complete

### Risk Mitigation

#### Technical Risks

**1. Database Performance**
- **Mitigation**: Proper indexing, query optimization, connection pooling
- **Monitoring**: Slow query logs, query performance metrics

**2. Race Conditions (Inventory)**
- **Mitigation**: Proper locking strategies, comprehensive concurrency tests
- **Monitoring**: Oversell detection, reconciliation jobs

**3. Payment Failures**
- **Mitigation**: Retry mechanism, idempotency, webhook verification
- **Monitoring**: Payment success rates, failure alerts

**4. Event Loss**
- **Mitigation**: Outbox pattern, guaranteed delivery
- **Monitoring**: Outbox queue depth, failed event alerts

#### Operational Risks

**1. Deployment Failures**
- **Mitigation**: CI/CD pipeline, automated tests, staging environment
- **Monitoring**: Deployment success rates, rollback procedures

**2. Performance Degradation**
- **Mitigation**: Load testing, performance benchmarks, caching
- **Monitoring**: Response time metrics, alert thresholds

### Success Criteria

#### Phase 1 Success (Orders & Payments)

- [ ] Orders can be created with idempotency
- [ ] Order status transitions work correctly
- [ ] Events are emitted via outbox
- [ ] Payments can be processed (Stripe)
- [ ] Webhooks are handled correctly
- [ ] All tests passing (80%+ coverage)
- [ ] Load testing shows acceptable performance
- [ ] Documentation complete

#### Overall Project Success

- [ ] All critical modules implemented
- [ ] 80%+ test coverage across codebase
- [ ] Performance meets requirements (< 200ms p95)
- [ ] Security audit passed
- [ ] Documentation complete
- [ ] Production deployment successful
- [ ] Monitoring and alerting in place

### Recommended Next Steps

#### Immediate Actions (This Week)

1. Review and approve this strategic plan
2. Set up development environment (if not done)
3. Create Phase 1 design document (Orders & Payments)
4. Set up CI/CD pipeline (if not done)
5. Create module template/starter

#### Week 1-2: Foundation

1. **Implement Outbox Pattern**
   - Add Outbox table
   - Create OutboxService
   - Create OutboxPublisher worker
   - Add tests

2. **Design Orders Module**
   - API contracts
   - Database schema review
   - State machine design
   - Event definitions

#### Week 3-5: Orders Module

1. Implement core functionality
2. Add comprehensive tests
3. Add metrics and logging
4. Code review and documentation

#### Week 6-8: Payments Module

1. Implement provider abstraction
2. Add Stripe integration
3. Implement webhook handling
4. Add comprehensive tests

### Final Thoughts

This is a **production system, not a prototype**. Every line of code should be:

- âœ… **Tested** - Comprehensive test coverage
- âœ… **Documented** - Clear documentation
- âœ… **Monitored** - Metrics and logging
- âœ… **Secure** - Security best practices
- âœ… **Performant** - Optimized for production
- âœ… **Maintainable** - Clean, readable code

**Remember:** Take time to do it right. Quality code is faster to maintain and extend than quick fixes.

**Focus on:**
1. Understanding the problem before coding
2. Writing tests first (TDD)
3. Refactoring continuously
4. Documenting as you go
5. Monitoring in production

This approach will result in a **production-grade e-commerce backend** that is maintainable, scalable, and reliable.

---

## ğŸ“š Additional Resources

### Documentation
- [Auth Security Design](../Auth%20Security%20Design.mdx) - Complete auth implementation guide
- [K6 Experiments Setup](../K6%20Experiments%20â€”%20Setup%20&%20Docs.md) - Load testing guide
- [Quickstart Guide](../quickstart.md) - Getting started guide

### Best Practices

1. **Code Quality**
   - Follow NestJS conventions
   - Use TypeScript strictly
   - Add JSDoc comments
   - Keep functions small and focused

2. **Security**
   - Validate all inputs (DTOs)
   - Use parameterized queries (Prisma)
   - Implement rate limiting
   - Log security events

3. **Performance**
   - Use Redis for hot reads
   - Implement caching strategies
   - Optimize database queries
   - Monitor performance metrics

4. **Testing**
   - Write tests before implementation (TDD)
   - Aim for 80%+ coverage
   - Test edge cases
   - Use property-based tests for algorithms

---

**Last Updated:** 2025-11-12  
**Maintainer:** Development Team  
**Status:** Active Development

**Completed Phases:**
- âœ… Phase 0: Foundation
- âœ… Phase 1: Orders & Payments
- âœ… Phase 2: Inventory & Cart
- âœ… Phase 3: Background Workers
- âœ… Phase 4: Search & Recommendations
- âœ… Phase 5: Observability Enhancement
- âœ… Phase 6: Testing & Validation
