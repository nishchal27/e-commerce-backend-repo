# üîÑ Phase 3: Background Workers

> **Implementation Guide** ‚Äî Complete documentation for background workers, webhook retries, payment reconciliation, and worker monitoring.

**Tech Stack:** NestJS ¬∑ BullMQ ¬∑ Redis ¬∑ Prometheus ¬∑ PostgreSQL

---

## üìã Table of Contents

1. [Overview](#-overview)
2. [Architecture](#-architecture)
3. [Webhook Retry Worker](#-webhook-retry-worker)
4. [Payment Reconciliation Worker](#-payment-reconciliation-worker)
5. [Worker Monitoring](#-worker-monitoring)
6. [Dead Letter Queue (DLQ)](#-dead-letter-queue-dlq)
7. [API Reference](#-api-reference)
8. [Configuration](#-configuration)
9. [Metrics & Observability](#-metrics--observability)
10. [Usage Examples](#-usage-examples)
11. [Testing](#-testing)
12. [Troubleshooting](#-troubleshooting)
13. [Best Practices](#-best-practices)

---

## üß≠ Overview

Phase 3 implements **background workers** using BullMQ for asynchronous job processing. This enables reliable, scalable processing of webhook retries, payment reconciliation, and other background tasks.

### ‚úÖ What's Implemented

| Component | Status | Features |
|-----------|--------|----------|
| **Webhook Retry Worker** | ‚úÖ Complete | Exponential backoff, idempotent processing, metrics |
| **Payment Reconciliation Worker** | ‚úÖ Complete | Status reconciliation, discrepancy detection, events |
| **Worker Monitoring** | ‚úÖ Complete | Queue health, metrics collection, health checks |
| **DLQ Handler** | ‚úÖ Complete | Failed job inspection, retry, archival |

### üéØ Key Features

- ‚úÖ **Automatic Retries** - Exponential backoff for failed jobs
- ‚úÖ **Queue Health Monitoring** - Real-time queue statistics
- ‚úÖ **DLQ Management** - Handle permanently failed jobs
- ‚úÖ **Comprehensive Metrics** - Prometheus metrics for all operations
- ‚úÖ **Health Check Endpoints** - HTTP endpoints for monitoring
- ‚úÖ **Idempotent Processing** - Safe to retry operations

---

## üèóÔ∏è Architecture

### System Components

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Workers Module                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  WebhookRetryProcessor                               ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Retries failed webhooks                           ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Exponential backoff                              ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Max 5 attempts                                   ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  PaymentReconciliationProcessor                      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Reconciles payment status                        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Detects discrepancies                            ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Updates payment/order status                     ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  WorkerMonitoringService                             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Monitors queue health                            ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Collects metrics                                ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Updates Prometheus                               ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  DLQHandlerService                                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Inspects failed jobs                             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Manual retry support                             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Job archival                                    ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚îÇ uses
                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              BullMQ + Redis + Prometheus                     ‚îÇ
‚îÇ  - Job queues (webhook-retry, payment-reconciliation)       ‚îÇ
‚îÇ  - Queue metrics (active, waiting, completed, failed)        ‚îÇ
‚îÇ  - Worker health monitoring                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Data Flow

#### Webhook Retry Flow

```
1. Webhook Processing Fails
   ‚îî‚îÄ> PaymentsController.processWebhook() catches error
       ‚îî‚îÄ> PaymentsService.queueWebhookRetry()
           ‚îî‚îÄ> Queue job to "webhook-retry" queue
           
2. WebhookRetryProcessor Picks Up Job
   ‚îî‚îÄ> Retries PaymentsService.processWebhook()
       ‚îú‚îÄ> Success: Job completes, metrics recorded
       ‚îî‚îÄ> Failure: Job retries with exponential backoff
           ‚îî‚îÄ> After 5 attempts: Job moves to DLQ
```

#### Payment Reconciliation Flow

```
1. Reconciliation Job Queued
   ‚îî‚îÄ> PaymentReconciliationProcessor.process()
       ‚îú‚îÄ> Fetch payment from database
       ‚îú‚îÄ> Check status with provider
       ‚îú‚îÄ> Compare statuses
       ‚îî‚îÄ> If mismatch:
           ‚îú‚îÄ> Update payment status
           ‚îú‚îÄ> Update order status (if payment succeeded)
           ‚îî‚îÄ> Emit reconciliation events
```

#### Worker Monitoring Flow

```
1. WorkerMonitoringService Starts
   ‚îî‚îÄ> Polls all queues every 30 seconds
       ‚îú‚îÄ> Get queue statistics (active, waiting, completed, failed)
       ‚îú‚îÄ> Update Prometheus metrics
       ‚îî‚îÄ> Log warnings if issues detected
```

---

## üîÑ Webhook Retry Worker

### Purpose

The **Webhook Retry Worker** automatically retries failed webhook processing with exponential backoff. This ensures webhooks are eventually processed even if temporary failures occur.

### How It Works

1. **Webhook Processing Fails** ‚Üí Error caught in `PaymentsController`
2. **Queue Retry Job** ‚Üí `PaymentsService.queueWebhookRetry()` queues job
3. **Processor Picks Up Job** ‚Üí `WebhookRetryProcessor` processes job
4. **Retry Processing** ‚Üí Calls `PaymentsService.processWebhook()` again
5. **Success** ‚Üí Job completes, metrics recorded
6. **Failure** ‚Üí Job retries with exponential backoff (2s, 4s, 8s, 16s, 32s)
7. **Max Attempts** ‚Üí After 5 attempts, job moves to DLQ

### Configuration

**File:** `src/common/workers/workers.module.ts`

```typescript
BullModule.registerQueue({
  name: 'webhook-retry',
  defaultJobOptions: {
    attempts: 5, // Retry up to 5 times
    backoff: {
      type: 'exponential',
      delay: 2000, // Initial delay: 2 seconds
    },
    removeOnComplete: {
      age: 3600, // Keep completed jobs for 1 hour
      count: 100,
    },
    removeOnFail: {
      age: 604800, // Keep failed jobs for 7 days
    },
  },
})
```

**Processor Configuration:**
- **Concurrency:** 3 webhooks at once
- **Rate Limiting:** 10 webhooks per second

### Integration

**PaymentsController** automatically queues retries:

```typescript
@Post('webhook')
async processWebhook(...) {
  try {
    return await this.paymentsService.processWebhook(payload, signature);
  } catch (error) {
    // Queue for retry (returns 200 OK to provider)
    await this.paymentsService.queueWebhookRetry(payload, signature, error);
    return { processed: false, queued_for_retry: true };
  }
}
```

### Metrics Tracked

- `webhook_retry_attempts_total` - Total retry attempts
- `webhook_retry_success_total` - Successful retries
- `webhook_retry_failures_total` - Failed retries (by error type)
- `webhook_retry_latency_seconds` - Retry latency histogram

---

## üí∞ Payment Reconciliation Worker

### Purpose

The **Payment Reconciliation Worker** periodically reconciles payment statuses with payment providers to detect and fix discrepancies.

### How It Works

1. **Reconciliation Job Queued** ‚Üí Job contains payment ID and provider info
2. **Processor Picks Up Job** ‚Üí `PaymentReconciliationProcessor` processes job
3. **Fetch Payment** ‚Üí Get payment from database
4. **Check Provider Status** ‚Üí Query provider API for current status
5. **Compare Statuses** ‚Üí Compare DB status vs provider status
6. **If Mismatch** ‚Üí Update payment and order status, emit events
7. **Record Metrics** ‚Üí Track reconciliation results

### Configuration

**File:** `src/common/workers/workers.module.ts`

```typescript
BullModule.registerQueue({
  name: 'payment-reconciliation',
  defaultJobOptions: {
    attempts: 3, // Retry up to 3 times
    backoff: {
      type: 'exponential',
      delay: 5000, // Initial delay: 5 seconds
    },
    removeOnComplete: {
      age: 86400, // Keep completed jobs for 24 hours
      count: 50,
    },
    removeOnFail: {
      age: 604800, // Keep failed jobs for 7 days
    },
  },
})
```

**Processor Configuration:**
- **Concurrency:** 2 reconciliations at once
- **Rate Limiting:** 20 reconciliations per minute

### Events Emitted

- `payment.reconciled.v1` - When payment status is reconciled
- `order.paid.v1` - When order status updated to PAID (if payment succeeded)

### Current Status

**Note:** Provider API integration is a placeholder. In production, implement actual provider API calls in `getProviderPaymentStatus()` method.

---

## üìä Worker Monitoring

### Purpose

The **Worker Monitoring Service** continuously monitors all BullMQ queues for health, backlog, and failures. It provides real-time visibility into worker performance.

### How It Works

1. **Service Initializes** ‚Üí Starts polling all queues
2. **Poll Every 30 Seconds** ‚Üí Collects queue statistics
3. **Update Prometheus** ‚Üí Updates gauge metrics
4. **Log Warnings** ‚Üí Alerts if issues detected (high backlog, failures)
5. **Health Check Endpoints** ‚Üí Exposes queue health via HTTP

### Monitored Queues

- `mail` - Email sending queue
- `webhook-retry` - Webhook retry queue
- `payment-reconciliation` - Payment reconciliation queue

### Metrics Collected

For each queue:
- **Active Jobs** - Currently being processed
- **Waiting Jobs** - Queued and waiting
- **Completed Jobs** - Successfully completed
- **Failed Jobs** - Permanently failed (in DLQ)
- **Delayed Jobs** - Scheduled for future execution

### Health Check Logic

A queue is considered **unhealthy** if:
- Waiting jobs > 100 (high backlog)
- Failed jobs > 50 (high failure rate)
- Delayed jobs > 1000 (scheduling issues)

### Prometheus Metrics

```
worker_active_jobs{queue="mail"} 2
worker_waiting_jobs{queue="webhook-retry"} 5
worker_completed_jobs{queue="payment-reconciliation"} 150
worker_failed_jobs{queue="webhook-retry"} 3
```

---

## üíÄ Dead Letter Queue (DLQ)

### Purpose

The **Dead Letter Queue (DLQ)** handles jobs that have failed after maximum retry attempts. It provides inspection, manual retry, and archival capabilities.

### How It Works

1. **Job Fails After Max Attempts** ‚Üí BullMQ moves job to failed queue
2. **DLQ Handler Tracks Failed Jobs** ‚Üí `DLQHandlerService` monitors failed queues
3. **Inspect Failed Jobs** ‚Üí View failed job details via API
4. **Manual Retry** ‚Üí Retry specific failed jobs
5. **Archive/Delete** ‚Üí Remove permanently failed jobs

### DLQ Management

**Get Failed Jobs:**
```bash
GET /workers/dlq/webhook-retry?limit=50
```

**Retry Failed Job:**
```bash
POST /workers/dlq/webhook-retry/{jobId}/retry
```

**Remove Failed Job:**
```bash
DELETE /workers/dlq/webhook-retry/{jobId}
```

### Failed Job Information

Each failed job includes:
- **Job ID** - Unique job identifier
- **Job Name** - Job type/name
- **Job Data** - Original job data
- **Failed Reason** - Error message
- **Attempts Made** - Number of retry attempts
- **Failed At** - Timestamp when job failed
- **Stack Trace** - Error stack trace (if available)

### Automatic Cleanup

Failed jobs are automatically removed after **7 days** (configurable in queue options). This prevents DLQ from growing indefinitely.

---

## üì° API Reference

### Worker Health Endpoints

#### GET /workers/health

Get health status for all queues.

**Authentication:** Required (ADMIN or MANAGER role)

**Response:**
```json
{
  "queues": [
    {
      "queue": "webhook-retry",
      "active": 2,
      "waiting": 5,
      "completed": 150,
      "failed": 3,
      "delayed": 0,
      "healthy": true,
      "issues": []
    },
    {
      "queue": "payment-reconciliation",
      "active": 1,
      "waiting": 0,
      "completed": 45,
      "failed": 0,
      "delayed": 0,
      "healthy": true,
      "issues": []
    }
  ],
  "overall": "healthy"
}
```

#### GET /workers/health/:queue

Get health status for a specific queue.

**Parameters:**
- `queue` - Queue name (e.g., "webhook-retry")

**Response:**
```json
{
  "queue": "webhook-retry",
  "active": 2,
  "waiting": 5,
  "completed": 150,
  "failed": 3,
  "delayed": 0,
  "healthy": true,
  "issues": []
}
```

### DLQ Endpoints

#### GET /workers/dlq

Get failed job counts for all queues.

**Response:**
```json
{
  "mail": 0,
  "webhook-retry": 3,
  "payment-reconciliation": 0
}
```

#### GET /workers/dlq/:queue

Get failed jobs for a specific queue.

**Parameters:**
- `queue` - Queue name
- `limit` (query) - Maximum number of jobs to return (default: 100)

**Response:**
```json
[
  {
    "id": "job-123",
    "name": "retry-webhook",
    "data": {
      "webhookEventId": "evt_123",
      "eventType": "payment_intent.succeeded",
      "provider": "stripe",
      "attemptNumber": 5
    },
    "failedReason": "Invalid webhook signature",
    "attemptsMade": 5,
    "failedAt": 1700000000000,
    "stacktrace": ["Error: Invalid webhook signature", "..."]
  }
]
```

#### POST /workers/dlq/:queue/:jobId/retry

Retry a failed job.

**Parameters:**
- `queue` - Queue name
- `jobId` - Job ID to retry

**Response:**
```json
{
  "success": true,
  "message": "Job job-123 queued for retry"
}
```

#### DELETE /workers/dlq/:queue/:jobId

Remove a failed job from DLQ.

**Parameters:**
- `queue` - Queue name
- `jobId` - Job ID to remove

**Response:**
```json
{
  "success": true,
  "message": "Job job-123 removed from DLQ"
}
```

---

## ‚öôÔ∏è Configuration

### Environment Variables

```bash
# Worker Monitoring
WORKER_MONITORING_INTERVAL=30000  # Polling interval in milliseconds (default: 30000)

# BullMQ Configuration
BULLMQ_REDIS_URL=redis://localhost:6379  # Redis URL for BullMQ (defaults to REDIS_URL)
REDIS_URL=redis://localhost:6379        # Redis URL (used if BULLMQ_REDIS_URL not set)
REDIS_HOST=localhost                     # Redis host
REDIS_PORT=6379                          # Redis port
REDIS_PASSWORD=                          # Redis password (optional)
```

### Queue Configuration

**Webhook Retry Queue:**
- **Max Attempts:** 5
- **Backoff:** Exponential (2s, 4s, 8s, 16s, 32s)
- **Concurrency:** 3
- **Rate Limit:** 10 jobs/second
- **Completed Jobs:** Kept for 1 hour
- **Failed Jobs:** Kept for 7 days

**Payment Reconciliation Queue:**
- **Max Attempts:** 3
- **Backoff:** Exponential (5s, 10s, 20s)
- **Concurrency:** 2
- **Rate Limit:** 20 jobs/minute
- **Completed Jobs:** Kept for 24 hours
- **Failed Jobs:** Kept for 7 days

### Customization

To modify queue configuration, edit `src/common/workers/workers.module.ts`:

```typescript
BullModule.registerQueue({
  name: 'webhook-retry',
  defaultJobOptions: {
    attempts: 5, // Change max attempts
    backoff: {
      type: 'exponential',
      delay: 2000, // Change initial delay
    },
    // ... other options
  },
})
```

---

## üìà Metrics & Observability

### Prometheus Metrics

All metrics are available at `/metrics` endpoint.

#### Webhook Retry Metrics

```
# Total retry attempts
webhook_retry_attempts_total{provider="stripe"} 25

# Successful retries
webhook_retry_success_total{provider="stripe"} 22

# Failed retries (by error type)
webhook_retry_failures_total{provider="stripe",error="Invalid signature"} 2
webhook_retry_failures_total{provider="stripe",error="Timeout"} 1

# Retry latency (histogram)
webhook_retry_latency_seconds_bucket{provider="stripe",le="0.5"} 20
webhook_retry_latency_seconds_bucket{provider="stripe",le="1"} 22
```

#### Worker Queue Metrics

```
# Active jobs
worker_active_jobs{queue="webhook-retry"} 2

# Waiting jobs
worker_waiting_jobs{queue="webhook-retry"} 5

# Completed jobs
worker_completed_jobs{queue="webhook-retry"} 150

# Failed jobs (DLQ)
worker_failed_jobs{queue="webhook-retry"} 3
```

### Useful Prometheus Queries

#### Webhook Retry Success Rate

```promql
rate(webhook_retry_success_total[5m]) / 
rate(webhook_retry_attempts_total[5m])
```

#### Average Retry Latency

```promql
rate(webhook_retry_latency_seconds_sum[5m]) / 
rate(webhook_retry_latency_seconds_count[5m])
```

#### Queue Backlog Alert

```promql
worker_waiting_jobs > 100
```

#### High Failure Rate Alert

```promql
rate(worker_failed_jobs[5m]) > 10
```

---

## üí° Usage Examples

### Example 1: Webhook Retry (Automatic)

```typescript
// In PaymentsController
@Post('webhook')
async processWebhook(...) {
  try {
    return await this.paymentsService.processWebhook(payload, signature);
  } catch (error) {
    // Automatically queues for retry
    await this.paymentsService.queueWebhookRetry(payload, signature, error);
    return { processed: false, queued_for_retry: true };
  }
}
```

### Example 2: Manual Webhook Retry Queue

```typescript
// In PaymentsService
async queueWebhookRetry(payload: any, signature: string, error: any) {
  const webhookEvent = this.paymentProvider.parseWebhookEvent(payload);
  
  const jobData: WebhookJobData = {
    webhookEventId: webhookEvent.id,
    eventType: webhookEvent.type,
    payload,
    signature,
    provider: this.paymentProvider.name,
    originalAttemptAt: new Date(),
    attemptNumber: 1,
    lastError: error.message,
  };

  await this.webhookRetryQueue.add('retry-webhook', jobData);
}
```

### Example 3: Queue Payment Reconciliation

```typescript
// Queue a payment for reconciliation
await paymentReconciliationQueue.add('reconcile-payment', {
  paymentId: payment.id,
  paymentIntentId: payment.paymentIntentId,
  provider: payment.provider,
});
```

### Example 4: Check Queue Health

```bash
# Get all queue health
curl -H "Authorization: Bearer <token>" \
  http://localhost:3000/workers/health

# Get specific queue health
curl -H "Authorization: Bearer <token>" \
  http://localhost:3000/workers/health/webhook-retry
```

### Example 5: Inspect DLQ

```bash
# Get failed jobs
curl -H "Authorization: Bearer <token>" \
  http://localhost:3000/workers/dlq/webhook-retry?limit=50

# Retry a failed job
curl -X POST \
  -H "Authorization: Bearer <token>" \
  http://localhost:3000/workers/dlq/webhook-retry/job-123/retry

# Remove a failed job
curl -X DELETE \
  -H "Authorization: Bearer <token>" \
  http://localhost:3000/workers/dlq/webhook-retry/job-123
```

---

## üß™ Testing

### Unit Tests

**Test Webhook Retry Processor:**
```typescript
describe('WebhookRetryProcessor', () => {
  it('should retry webhook processing', async () => {
    // Test implementation
  });

  it('should record metrics on success', async () => {
    // Test implementation
  });

  it('should record metrics on failure', async () => {
    // Test implementation
  });
});
```

### Integration Tests

**Test Webhook Retry Flow:**
```typescript
describe('POST /payments/webhook (with retry)', () => {
  it('should queue webhook for retry on failure', async () => {
    // Test implementation
  });

  it('should process queued webhook successfully', async () => {
    // Test implementation
  });
});
```

### Load Testing

**Test Worker Under Load:**
```javascript
// k6 script
import http from 'k6/http';

export const options = {
  stages: [
    { duration: '30s', target: 50 },  // Ramp up
    { duration: '1m', target: 100 },   // Stay at 100
    { duration: '30s', target: 0 },   // Ramp down
  ],
};

export default function () {
  // Trigger webhook failures to test retry mechanism
  const res = http.post('https://api.example.com/payments/webhook', payload);
  // ...
}
```

---

## üîß Troubleshooting

### Issue: Webhook Retries Not Working

**Symptoms:**
- Webhooks fail but not queued for retry
- No jobs in webhook-retry queue

**Solutions:**
1. Check `PaymentsController.processWebhook()` error handling
2. Verify `PaymentsService.queueWebhookRetry()` is called
3. Check BullMQ connection (Redis)
4. Verify queue is registered in `WorkersModule`

**Debug:**
```typescript
// Add logging in PaymentsController
catch (error) {
  this.logger.error(`Webhook failed: ${error.message}`, error.stack);
  await this.paymentsService.queueWebhookRetry(payload, signature, error);
}
```

### Issue: High Queue Backlog

**Symptoms:**
- `worker_waiting_jobs` metric is high (> 100)
- Jobs taking long to process

**Solutions:**
1. Increase processor concurrency
2. Scale workers horizontally
3. Check for slow job processing
4. Optimize job processing logic

**Configuration:**
```typescript
@Processor('webhook-retry', {
  concurrency: 10, // Increase from 3 to 10
})
```

### Issue: Jobs Stuck in DLQ

**Symptoms:**
- Many failed jobs in DLQ
- Jobs failing after max attempts

**Solutions:**
1. Inspect failed job reasons
2. Fix underlying issue (e.g., invalid webhook signature)
3. Retry jobs manually after fix
4. Adjust max attempts if needed

**Debug:**
```bash
# Get failed jobs
GET /workers/dlq/webhook-retry

# Inspect failure reason
# Fix issue
# Retry jobs
POST /workers/dlq/webhook-retry/{jobId}/retry
```

### Issue: Worker Monitoring Not Working

**Symptoms:**
- No metrics in Prometheus
- Health endpoints return errors

**Solutions:**
1. Verify `WorkerMonitoringService` is initialized
2. Check BullMQ connection
3. Verify queues are registered
4. Check logs for errors

**Debug:**
```typescript
// Check if service is running
// Logs should show: "Starting worker monitoring (interval: 30000ms)"
```

### Issue: Payment Reconciliation Not Running

**Symptoms:**
- No reconciliation jobs processed
- Payment statuses not updated

**Solutions:**
1. Verify jobs are being queued
2. Check processor is running
3. Implement provider API integration
4. Check logs for errors

**Note:** Currently, `getProviderPaymentStatus()` is a placeholder. Implement actual provider API calls.

---

## ‚úÖ Best Practices

### 1. Error Handling

- **Always catch errors** in job processors
- **Log errors** with context (job ID, attempt number)
- **Don't throw** unless you want job to retry
- **Record metrics** for all outcomes

### 2. Idempotency

- **Make jobs idempotent** - safe to retry
- **Check for duplicates** before processing
- **Use idempotency keys** for critical operations

### 3. Retry Strategy

- **Use exponential backoff** for transient failures
- **Set reasonable max attempts** (3-5 for most jobs)
- **Move to DLQ** after max attempts
- **Monitor DLQ** for permanent failures

### 4. Monitoring

- **Monitor queue health** regularly
- **Set up alerts** for high backlog/failures
- **Track metrics** (latency, success rate)
- **Review DLQ** periodically

### 5. Resource Management

- **Limit concurrency** to prevent resource exhaustion
- **Use rate limiting** to prevent overwhelming systems
- **Clean up old jobs** (completed/failed)
- **Monitor Redis memory** usage

### 6. Job Data

- **Keep job data small** (avoid large payloads)
- **Use references** (IDs) instead of full objects
- **Include context** (request ID, trace ID)
- **Version job data** for schema evolution

### 7. Testing

- **Test retry logic** with failures
- **Test DLQ handling** with max attempts
- **Load test** workers under high load
- **Monitor** during load tests

---

## üìÅ File Structure

### Workers Module

```
src/common/workers/
‚îú‚îÄ‚îÄ workers.module.ts                    # Main module definition
‚îú‚îÄ‚îÄ workers.controller.ts                # HTTP endpoints
‚îú‚îÄ‚îÄ interfaces/
‚îÇ   ‚îî‚îÄ‚îÄ webhook-job.interface.ts        # Webhook job data structure
‚îú‚îÄ‚îÄ processors/
‚îÇ   ‚îú‚îÄ‚îÄ webhook-retry.processor.ts      # Webhook retry worker
‚îÇ   ‚îî‚îÄ‚îÄ payment-reconciliation.processor.ts  # Payment reconciliation worker
‚îî‚îÄ‚îÄ services/
    ‚îú‚îÄ‚îÄ worker-monitoring.service.ts     # Queue health monitoring
    ‚îî‚îÄ‚îÄ dlq-handler.service.ts           # Dead Letter Queue management
```

### Integration Points

- **PaymentsModule** - Registers webhook-retry queue, exports PaymentsService
- **WorkersModule** - Registers processors, monitoring, DLQ handler
- **PrometheusModule** - Provides metrics service
- **EventsModule** - Provides OutboxService for event emission

---

## üîó Related Documentation

- [Phase 1: Orders & Payments](./Phase-1-Orders-Payments-Outbox.mdx) - Outbox pattern, orders, payments
- [Phase 2: Inventory & Cart](../architecture/Modules-Architecture%20&%20Experimentation.mdx) - Inventory and cart modules
- [A/B Testing Guide](../experiments/A-B-Testing-Guide.mdx) - Experiment system
- [Architecture Guide](../architecture/Modules-Architecture%20&%20Experimentation.mdx) - Overall architecture

---

## üìö Summary

### What You Learned

1. **Background Workers** - BullMQ workers for async processing
2. **Webhook Retries** - Automatic retry with exponential backoff
3. **Payment Reconciliation** - Status reconciliation with providers
4. **Worker Monitoring** - Queue health and metrics
5. **DLQ Management** - Handling permanently failed jobs

### Key Takeaways

- ‚úÖ Workers use **BullMQ** for reliable job processing
- ‚úÖ **Exponential backoff** prevents overwhelming systems
- ‚úÖ **DLQ** handles permanently failed jobs
- ‚úÖ **Monitoring** provides real-time visibility
- ‚úÖ **Metrics** enable observability and alerting

### Next Steps

1. **Test Workers** - Verify retry and reconciliation work
2. **Set Up Alerts** - Alert on high backlog/failures
3. **Monitor Metrics** - Create Grafana dashboards
4. **Implement Provider API** - Complete payment reconciliation
5. **Add More Workers** - Extend for other use cases

---

**Last Updated:** 2025-11-12  
**Status:** ‚úÖ Production Ready

