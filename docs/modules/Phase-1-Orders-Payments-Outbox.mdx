# ğŸ“¦ Phase 1 Modules: Orders, Payments & Outbox Pattern

> **Implementation Guide** â€” Complete documentation for Orders, Payments modules and the Transactional Outbox pattern implementation.

**Tech Stack:** NestJS Â· PostgreSQL Â· Prisma Â· Redis Â· BullMQ Â· Stripe

---

## ğŸ“‹ Table of Contents

1. [Overview](#-overview)
2. [Outbox Pattern](#-outbox-pattern)
3. [Orders Module](#-orders-module)
4. [Payments Module](#-payments-module)
5. [Integration Guide](#-integration-guide)
6. [API Reference](#-api-reference)
7. [Testing](#-testing)
8. [Troubleshooting](#-troubleshooting)

---

## ğŸ§­ Overview

Phase 1 implements the core e-commerce functionality: **Orders** and **Payments**, along with the **Transactional Outbox pattern** for reliable event publishing.

### âœ… What's Implemented

| Component | Status | Features |
|-----------|--------|----------|
| **Outbox Pattern** | âœ… Complete | Event storage, publisher worker, Redis Stream integration |
| **Orders Module** | âœ… Complete | Order creation, status state machine, idempotency, events |
| **Payments Module** | âœ… Complete | Stripe integration, webhooks, idempotency, events |

### ğŸ¯ Key Features

- âœ… **Idempotent Operations** - Order and payment creation with idempotency keys
- âœ… **Event-Driven** - Domain events via Outbox pattern (order.created, payment.succeeded, etc.)
- âœ… **State Machine** - Order status transitions with validation
- âœ… **Provider Abstraction** - Payment provider interface (Stripe implemented)
- âœ… **Webhook Handling** - Idempotent webhook processing with signature verification
- âœ… **Observability** - Prometheus metrics, structured logging, request correlation

---

## ğŸ“¨ Outbox Pattern

### ğŸ¯ Purpose

The **Transactional Outbox pattern** ensures reliable event publishing by storing events in the database within the same transaction as business logic. This guarantees **at-least-once delivery** and prevents lost events.

### ğŸ—ï¸ Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Business Logic â”‚
â”‚  (Orders/Payments)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Same Transaction
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Outbox Table   â”‚  â† Events stored here
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Polling (5s interval)
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OutboxPublisher â”‚  â† Worker polls and publishes
â”‚    Processor    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â”‚ Publish
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Redis Stream   â”‚  â† Event bus (can extend to Kafka)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“ File Structure

```
src/common/events/
â”œâ”€â”€ events.module.ts                    # Events module definition
â”œâ”€â”€ outbox.service.ts                   # Write events to Outbox
â”œâ”€â”€ interfaces/
â”‚   â””â”€â”€ domain-event.interface.ts        # Domain event structure
â””â”€â”€ processors/
    â””â”€â”€ outbox-publisher.processor.ts    # Worker that publishes events
```

### ğŸ”§ Database Schema

```prisma
model Outbox {
  id        String   @id @default(uuid())
  topic     String   // Event topic (e.g., "order.created")
  payload   Json     // Full event envelope
  createdAt DateTime @default(now())
  sentAt    DateTime? // When published (null = not yet sent)
  attempts Int      @default(0) // Retry count
  locked    Boolean  @default(false) // Lock for worker processing

  @@index([createdAt]) // For polling unsent events
  @@index([sentAt])    // For cleanup
  @@index([locked])    // For finding unlocked events
  @@map("outbox")
}
```

### ğŸ’» Usage

#### 1. Write Event in Transaction

```typescript
import { OutboxService } from '../../common/events/outbox.service';

// In your service method
await this.prisma.$transaction(async (tx) => {
  // 1. Create order
  const order = await tx.order.create({
    data: {
      userId: user.id,
      totalAmount: 99.99,
      status: 'CREATED',
      // ...
    },
  });

  // 2. Write event to outbox (same transaction)
  await this.outboxService.writeEvent({
    topic: 'order.created',
    event: this.outboxService.createEvent(
      'order.created.v1',
      {
        order_id: order.id,
        user_id: order.userId,
        total_amount: order.totalAmount.toString(),
        items: orderItems,
      },
      {
        trace_id: traceId,
        request_id: requestId,
      },
    ),
    tx, // Use same transaction client
  });

  return order;
});
```

#### 2. Event Structure

All events follow this standard envelope:

```typescript
interface DomainEvent {
  event_id: string;        // UUID v4
  event_type: string;       // e.g., "order.created.v1"
  timestamp: string;        // ISO 8601
  source: string;           // "orders-service"
  trace_id?: string;        // OpenTelemetry trace ID
  request_id?: string;      // Request ID from middleware
  payload: Record<string, any>;  // Domain-specific data
  meta?: {
    env?: string;
    version?: string;
    feature_flags?: string[];
  };
}
```

#### 3. Helper Methods

```typescript
// Create event with standard fields
const event = outboxService.createEvent(
  'order.created.v1',
  { order_id: order.id, user_id: order.userId },
  { trace_id: traceId, request_id: requestId }
);

// Write event (with or without transaction)
await outboxService.writeEvent({
  topic: 'order.created',
  event,
  tx, // Optional: use transaction client
});
```

### ğŸ”„ Outbox Publisher Worker

The `OutboxPublisherProcessor` automatically:
- Polls Outbox table every 5 seconds
- Locks events to prevent concurrent processing
- Publishes events to Redis Stream
- Marks events as sent after successful publishing
- Retries failed events (up to 5 attempts)

**Configuration:**
- Polling interval: 5 seconds (configurable)
- Batch size: 100 events per poll
- Max attempts: 5 (then goes to DLQ)

### ğŸ“Š Events Published

| Event Type | Topic | When Emitted | Payload |
|------------|-------|--------------|---------|
| `order.created.v1` | `order.created` | Order created | `order_id`, `user_id`, `total_amount`, `items` |
| `order.status.updated.v1` | `order.updated` | Order status changed | `order_id`, `old_status`, `new_status` |
| `payment.created.v1` | `payment.created` | Payment intent created | `payment_id`, `order_id`, `amount` |
| `payment.succeeded.v1` | `payment.succeeded` | Payment confirmed | `payment_id`, `order_id`, `amount` |
| `payment.failed.v1` | `payment.failed` | Payment failed | `payment_id`, `order_id`, `reason` |

---

## ğŸ›’ Orders Module

### ğŸ¯ Purpose

The Orders module handles order lifecycle management, from creation to delivery, with state machine validation and event emission.

### ğŸ“ File Structure

```
src/modules/orders/
â”œâ”€â”€ orders.module.ts                    # Module definition
â”œâ”€â”€ orders.service.ts                   # Business logic
â”œâ”€â”€ orders.controller.ts                # HTTP endpoints
â”œâ”€â”€ orders.repository.ts                # Data access layer
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-order.dto.ts             # Order creation DTO
â”‚   â”œâ”€â”€ update-order-status.dto.ts       # Status update DTO
â”‚   â””â”€â”€ order-response.dto.ts           # Response DTOs
â””â”€â”€ interfaces/
    â””â”€â”€ order-status.interface.ts        # Status transition logic
```

### ğŸ”„ Order Status State Machine

```
CREATED â†’ PAID â†’ SHIPPED â†’ DELIVERED
   â†“
CANCELLED (terminal)
```

**Valid Transitions:**
- `CREATED` â†’ `PAID` (when payment succeeds)
- `CREATED` â†’ `CANCELLED` (user/admin cancels)
- `PAID` â†’ `SHIPPED` (admin ships order)
- `SHIPPED` â†’ `DELIVERED` (admin marks delivered)
- `PAID` â†’ `CANCELLED` (admin cancels after payment)

**Invalid transitions throw `BadRequestException`.**

### ğŸ’» Usage

#### Create Order

```typescript
// POST /orders
{
  "items": [
    { "sku": "TSHIRT-SM-RED", "quantity": 2 },
    { "sku": "TSHIRT-MD-BLUE", "quantity": 1 }
  ],
  "idempotencyKey": "unique-key-123" // Optional: prevents duplicates
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "id": "order-uuid",
    "userId": "user-uuid",
    "totalAmount": "99.99",
    "status": "CREATED",
    "items": [
      {
        "sku": "TSHIRT-SM-RED",
        "quantity": 2,
        "unitPrice": "29.99",
        "totalPrice": "59.98"
      }
    ],
    "createdAt": "2025-11-12T10:00:00.000Z"
  }
}
```

#### Get Order

```typescript
// GET /orders/:id
// Returns order if user owns it or is admin/manager
```

#### Update Order Status

```typescript
// PATCH /orders/:id/status
// Requires ADMIN or MANAGER role
{
  "status": "SHIPPED"
}
```

### ğŸ” Security

- âœ… All endpoints require authentication (`@UseGuards(JwtAuthGuard)`)
- âœ… Users can only access their own orders (enforced in service)
- âœ… Status updates require `ADMIN` or `MANAGER` role
- âœ… Idempotency keys prevent duplicate orders

### ğŸ“Š Events Emitted

1. **`order.created.v1`** - When order is created
   ```json
   {
     "event_type": "order.created.v1",
     "payload": {
       "order_id": "order-uuid",
       "user_id": "user-uuid",
       "total_amount": "99.99",
       "items": [...]
     }
   }
   ```

2. **`order.status.updated.v1`** - When status changes
   ```json
   {
     "event_type": "order.status.updated.v1",
     "payload": {
       "order_id": "order-uuid",
       "old_status": "CREATED",
       "new_status": "PAID"
     }
   }
   ```

### ğŸ§ª Testing

```typescript
// Unit test example
describe('OrdersService', () => {
  it('should create order with idempotency key', async () => {
    const order = await service.create({
      userId: 'user-123',
      items: [{ sku: 'SKU-001', quantity: 1 }],
      idempotencyKey: 'key-123',
    });

    // Second call with same key should return same order
    const duplicate = await service.create({
      userId: 'user-123',
      items: [{ sku: 'SKU-001', quantity: 1 }],
      idempotencyKey: 'key-123',
    });

    expect(duplicate.id).toBe(order.id);
  });
});
```

---

## ğŸ’³ Payments Module

### ğŸ¯ Purpose

The Payments module handles payment processing with provider abstraction, webhook handling, and integration with Orders module.

### ğŸ“ File Structure

```
src/modules/payments/
â”œâ”€â”€ payments.module.ts                  # Module definition
â”œâ”€â”€ payments.service.ts                 # Business logic
â”œâ”€â”€ payments.controller.ts              # HTTP endpoints
â”œâ”€â”€ providers/
â”‚   â”œâ”€â”€ payment-provider.interface.ts   # Provider interface
â”‚   â””â”€â”€ stripe.provider.ts              # Stripe implementation
â””â”€â”€ dto/
    â”œâ”€â”€ create-payment.dto.ts           # Payment creation DTO
    â”œâ”€â”€ confirm-payment.dto.ts          # Payment confirmation DTO
    â””â”€â”€ refund-payment.dto.ts          # Refund DTO
```

### ğŸ”§ Provider Abstraction

The module uses a provider interface to support multiple payment providers:

```typescript
interface IPaymentProvider {
  name: string;
  createPaymentIntent(amount: number, currency: string, metadata: any): Promise<PaymentIntent>;
  confirmPayment(paymentIntentId: string): Promise<PaymentStatus>;
  refundPayment(paymentId: string, amount: number): Promise<RefundResult>;
  verifyWebhookSignature(payload: string, signature: string): boolean;
}
```

**Currently Implemented:**
- âœ… Stripe (`StripeProvider`)

**Future:**
- â³ PayPal
- â³ Square

### ğŸ’» Usage

#### Create Payment Intent

```typescript
// POST /payments
{
  "orderId": "order-uuid",
  "idempotencyKey": "payment-key-123" // Optional
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "id": "payment-uuid",
    "orderId": "order-uuid",
    "amount": "99.99",
    "currency": "USD",
    "status": "PENDING",
    "clientSecret": "pi_xxx_secret_xxx", // For Stripe
    "paymentIntentId": "pi_xxx"
  }
}
```

#### Confirm Payment

```typescript
// POST /payments/:id/confirm
{
  "paymentMethodId": "pm_xxx" // Stripe payment method ID
}
```

#### Webhook Handler

```typescript
// POST /payments/webhook
// Public endpoint (signature verified)
// Handles Stripe webhook events:
// - payment_intent.succeeded
// - payment_intent.payment_failed
```

**Webhook Flow:**
1. Stripe sends webhook to `/payments/webhook`
2. Signature is verified
3. Event is processed idempotently (checks `webhookEventId`)
4. Order status is updated if payment succeeds
5. Event is emitted (`payment.succeeded.v1` or `payment.failed.v1`)

### ğŸ” Security

- âœ… Payment creation requires authentication
- âœ… Webhook signature verification (prevents spoofing)
- âœ… Idempotent webhook processing (prevents duplicate processing)
- âœ… Idempotency keys for payment creation

### ğŸ“Š Events Emitted

1. **`payment.created.v1`** - When payment intent is created
2. **`payment.succeeded.v1`** - When payment succeeds (via webhook or confirmation)
3. **`payment.failed.v1`** - When payment fails

### ğŸ§ª Testing

```typescript
// Integration test example
describe('POST /payments/webhook', () => {
  it('should process Stripe webhook idempotently', async () => {
    const webhookPayload = {
      type: 'payment_intent.succeeded',
      data: { object: { id: 'pi_xxx', ... } },
    };

    // First call
    await request(app)
      .post('/payments/webhook')
      .set('stripe-signature', validSignature)
      .send(webhookPayload)
      .expect(200);

    // Second call (same webhook) should be idempotent
    await request(app)
      .post('/payments/webhook')
      .set('stripe-signature', validSignature)
      .send(webhookPayload)
      .expect(200);

    // Payment should only be processed once
    const payment = await prisma.payment.findUnique({
      where: { paymentIntentId: 'pi_xxx' },
    });
    expect(payment.status).toBe('SUCCEEDED');
  });
});
```

---

## ğŸ”— Integration Guide

### Adding Events to a New Module

1. **Import EventsModule:**
   ```typescript
   import { EventsModule } from '../../common/events/events.module';

   @Module({
     imports: [EventsModule, ...],
     // ...
   })
   ```

2. **Inject OutboxService:**
   ```typescript
   constructor(
     private readonly outboxService: OutboxService,
     // ...
   ) {}
   ```

3. **Write Event in Transaction:**
   ```typescript
   await this.prisma.$transaction(async (tx) => {
     // Business logic
     const entity = await tx.entity.create({ ... });

     // Write event
     await this.outboxService.writeEvent({
       topic: 'entity.created',
       event: this.outboxService.createEvent(
         'entity.created.v1',
         { entity_id: entity.id, ... },
         { trace_id, request_id }
       ),
       tx,
     });
   });
   ```

### Adding a New Payment Provider

1. **Implement Interface:**
   ```typescript
   @Injectable()
   export class PayPalProvider implements IPaymentProvider {
     name = 'paypal';
     
     async createPaymentIntent(...) { ... }
     async confirmPayment(...) { ... }
     // ...
   }
   ```

2. **Register in Module:**
   ```typescript
   @Module({
     providers: [
       PaymentsService,
       StripeProvider,
       PayPalProvider, // Add here
     ],
   })
   ```

3. **Select in Service:**
   ```typescript
   const providerName = this.configService.get('PAYMENT_PROVIDER', 'stripe');
   if (providerName === 'paypal') {
     this.paymentProvider = this.paypalProvider;
   }
   ```

---

## ğŸ“š API Reference

### Orders Endpoints

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| `POST` | `/orders` | âœ… Required | Create order |
| `GET` | `/orders/:id` | âœ… Required | Get order by ID |
| `GET` | `/orders` | âœ… Required | Get user's orders (paginated) |
| `PATCH` | `/orders/:id/status` | âœ… Admin/Manager | Update order status |

### Payments Endpoints

| Method | Endpoint | Auth | Description |
|--------|----------|------|-------------|
| `POST` | `/payments` | âœ… Required | Create payment intent |
| `POST` | `/payments/:id/confirm` | âœ… Required | Confirm payment |
| `POST` | `/payments/webhook` | ğŸ”’ Signature | Process webhook |
| `POST` | `/payments/:id/refund` | âœ… Admin | Refund payment |

---

## ğŸ§ª Testing

### Unit Tests

```bash
# Run unit tests
npm test -- orders.service.spec.ts
npm test -- payments.service.spec.ts
```

### Integration Tests

```bash
# Run E2E tests
npm run test:e2e -- orders.e2e-spec.ts
npm run test:e2e -- payments.e2e-spec.ts
```

### Load Testing

```bash
# k6 load test (create script)
k6 run k6/orders-test.js
k6 run k6/payments-test.js
```

---

## ğŸ”§ Troubleshooting

### Events Not Publishing

**Symptoms:** Events in Outbox table but `sentAt` is null.

**Solutions:**
1. Check `OutboxPublisherProcessor` is running (should log polling activity)
2. Check Redis connection (events published to Redis Stream)
3. Check for errors in logs
4. Verify `locked` flag is not stuck (should be false after processing)

### Duplicate Orders

**Symptoms:** Multiple orders created with same data.

**Solutions:**
1. Always use `idempotencyKey` in requests
2. Check idempotency key is unique per user/operation
3. Verify idempotency check in service is working

### Payment Webhook Not Processing

**Symptoms:** Webhook received but payment not updated.

**Solutions:**
1. Verify webhook signature (check `STRIPE_WEBHOOK_SECRET`)
2. Check webhook event ID is unique (idempotency)
3. Check logs for errors
4. Verify order exists and is in correct status

### Order Status Transition Fails

**Symptoms:** Status update throws `BadRequestException`.

**Solutions:**
1. Check valid transition (see state machine diagram)
2. Verify order is not in terminal status
3. Check user has required role (ADMIN/MANAGER for status updates)

---

## ğŸ“Š Metrics

### Prometheus Metrics

| Metric | Type | Labels | Description |
|--------|------|--------|-------------|
| `orders_created_total` | Counter | `status` | Orders created |
| `orders_by_status` | Gauge | `status` | Current order count by status |
| `payments_created_total` | Counter | `provider` | Payment intents created |
| `payments_succeeded_total` | Counter | `provider` | Successful payments |
| `payments_failed_total` | Counter | `provider`, `reason` | Failed payments |
| `outbox_events_published_total` | Counter | `topic` | Events published |
| `outbox_events_failed_total` | Counter | `topic` | Failed event publishing |

### Query Examples

```promql
# Orders created today
rate(orders_created_total[1h])

# Payment success rate
rate(payments_succeeded_total[5m]) / rate(payments_created_total[5m])

# Events published per topic
sum by (topic) (outbox_events_published_total)
```

---

## ğŸš€ Future Enhancements

### Orders Module
- [ ] Order cancellation with refund logic
- [ ] Order history and audit trail
- [ ] Bulk order operations
- [ ] Order search and filtering

### Payments Module
- [ ] PayPal provider implementation
- [ ] Payment method management
- [ ] Subscription payments
- [ ] Payment reconciliation job

### Outbox Pattern
- [ ] Kafka integration (in addition to Redis Stream)
- [ ] Dead Letter Queue (DLQ) for failed events
- [ ] Event replay capability
- [ ] Event versioning and schema evolution

---

## ğŸ“š Related Documentation

- [Auth Security Design](../Auth%20Security%20Design.mdx) - Authentication and security
- [Modules Architecture](../../architecture/Modules-Architecture%20&%20Experimentation.mdx) - Overall architecture
- [Quickstart Guide](../quickstart.md) - Getting started

---

**Last Updated:** 2025-11-12  
**Status:** âœ… Phase 1 Complete  
**Next Phase:** Inventory & Cart (Phase 2)

